<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lionel's Blog</title><link>https://lixianwa.github.io/</link><description>Recent content on Lionel's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>&lt;a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">&lt;img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" />&lt;/a>&lt;br />本作品采用&lt;a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a>进行许可。</copyright><lastBuildDate>Sat, 25 Dec 2021 13:43:37 +0800</lastBuildDate><atom:link href="https://lixianwa.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Go语言SOLID实践系列二之开闭原则</title><link>https://lixianwa.github.io/posts/go%E8%AF%AD%E8%A8%80solid%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97%E4%BA%8C%E4%B9%8B%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</link><pubDate>Sat, 25 Dec 2021 13:43:37 +0800</pubDate><guid>https://lixianwa.github.io/posts/go%E8%AF%AD%E8%A8%80solid%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97%E4%BA%8C%E4%B9%8B%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</guid><description>&lt;p>引用wikipedia上对&lt;code>开闭原则&lt;/code>的解释：&lt;/p>
&lt;blockquote>
&lt;p>在面向对象编程领域中，开闭原则 (The Open/Closed Principle, OCP) 规定“软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的”，这意味着一个实体是允许在不改变它的源代码的前提下变更它的行为。该特性在产品化的环境中是特别有价值的，在这种环境中，改变源代码需要代码审查，单元测试以及诸如此类的用以确保产品使用品质的过程。遵循这种原则的代码在扩展时并不发生改变，因此无需上述的过程。&lt;/p>
&lt;/blockquote>
&lt;p>在本文中，我们将通过实践的方式深入探索这一原则。&lt;/p></description></item><item><title>SOLID的Go实践系列一之单一职责原则</title><link>https://lixianwa.github.io/posts/solid%E7%9A%84go%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97%E4%B8%80%E4%B9%8B%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</link><pubDate>Thu, 23 Dec 2021 11:17:05 +0800</pubDate><guid>https://lixianwa.github.io/posts/solid%E7%9A%84go%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97%E4%B8%80%E4%B9%8B%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</guid><description>&lt;h2 id="什么是solid">什么是&lt;code>SOLID&lt;/code>?&lt;/h2>
&lt;p>以下引用wikipedia上的解释：&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>SOLID&lt;/code>指面向对象编程和面向对象设计的五个基本原则。当这些原则被一起应用时，它们使得一个程序员开发一个容易进行软件维护和扩展的系统变得更加可能。&lt;code>SOLID&lt;/code>所包含的原则是通过引发编程者进行软件源代码的代码重构进行软件的代码异味清扫，从而使得软件清晰可读以及可扩展时可以应用的指南。&lt;code>SOLID&lt;/code>被典型的应用在测试驱动开发上，并且是敏捷开发以及自适应软件开发的基本原则的重要组成部分&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes最佳实践</title><link>https://lixianwa.github.io/posts/kubernetes%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link><pubDate>Wed, 22 Dec 2021 16:22:03 +0800</pubDate><guid>https://lixianwa.github.io/posts/kubernetes%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid><description>&lt;p>容器的使用越来越多，导致对Kubernetes等容器编排平台的需求随之上升。使用容器来打包应用程序，极大地简化了应用程序从开发到生产的部署过程。毫无疑问，Kubernetes作为一个平台协调器，通过引入其深奥的方式，进一步简化了这个过程。&lt;/p>
&lt;p>今天，我想谈谈我在使用Kubernetes时学到的一些好的做法，这些做法可以实现安全部署并推动集群的效率。
那么，让我们开始吧。&lt;/p></description></item><item><title>在Kubernetes上gRPC是如何通过Headless Service负载均衡</title><link>https://lixianwa.github.io/posts/%E5%9C%A8kubernetes%E4%B8%8Agrpc%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87headless-service%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</link><pubDate>Mon, 20 Dec 2021 14:59:52 +0800</pubDate><guid>https://lixianwa.github.io/posts/%E5%9C%A8kubernetes%E4%B8%8Agrpc%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87headless-service%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</guid><description>&lt;p>gRPC 是用于进程间通信的最流行的现代 RPC 框架之一。 它是微服务架构的绝佳选择。 而且，毫无疑问，部署微服务应用程序最流行的方式是 Kubernetes。&lt;/p>
&lt;p>Kubernetes部署可以具有相同的后端实例，为许多客户端请求提供服务。 Kubernetes 的 ClusterIP 服务提供负载均衡的IP地址。 但是这种默认的负载平衡不适用于gRPC开箱即用。&lt;/p>
&lt;p>如果你使用gRPC并在 Kubernetes 上部署了许多后端服务，那么本文档适合你。&lt;/p></description></item><item><title>关于Go1.18你想知道的都在这里</title><link>https://lixianwa.github.io/posts/%E5%85%B3%E4%BA%8Ego1.18%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C/</link><pubDate>Sun, 19 Dec 2021 13:22:09 +0800</pubDate><guid>https://lixianwa.github.io/posts/%E5%85%B3%E4%BA%8Ego1.18%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C/</guid><description>原文：https://betterprogramming.pub/golang-1-18-what-you-need-to-know-a5701f7e14ab
在Go 1.18中，有两件大事是你需要知道的。类型参数(在其他语言中称为泛型)和模糊测试，但为什么它们如此重要？
Golang团队正在努力开发Go1.18，该版本将于2022年2月发布，它将是一个大的版本。Go1.18将引入泛型和模糊测试，这有可能彻底改变我们开发和测试Go程序的方式。我们将在下面看一下这两个新特性。
类型参数 类型参数将允许Go程序员用占位符类型名称定义函数和方法。这将允许开发人员编写可以在项目的不同部分重复使用的代码，但仍然可以对他们期望支持的所有数据类型进行通用处理。
让我们来看看一个普通的Go函数（在1.18之前），计算两个数中较小的一个数。
func min(a, b int) int { if a &amp;lt; b { return a } return b } 上面这个方法中，我们把两个整数作为参数，min(1,2)和min(2,1)都将返回1。到目前为止还不错，但是当你想得到两个浮点数的较小值时，怎么办呢？我们将不得不写一个新的函数，它需要两个浮点数作为参数，而且我们不能重复使用第一个函数的代码。函数的主体仍然是完全相同的代码。如果我们想得到两个float64数的较小值，我们将不得不再次编写相同的函数，以float64作为参数。
现在让我们来看看Go的泛型。你现在可以用一个任意的占位符类型名称来定义函数，这个名称将作为其他类型的参数。在Go中，泛型是以类型T的形式来写的。
这意味着你可以用任何占位符类型的名字来定义一个函数，这个名字以后会被另一个参数填入。现在我们用新的泛型方法重构之前的例子。
type numeric interface { type int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, float32, float64 } func min[T numeric](a, b T) T { if a &amp;lt; b { return a } return b } 如上，这段代码有点长。首先，我们定义一个接口，它将所有的数字类型声明为numeric的新类型。这意味着我们可以在泛型中使用float64和int。然后，像之前一样，我们定义一个新的min函数。
不同的是，现在这个函数在头部有一个类型参数：min[T numeric]&amp;hellip;. 这告诉Go，类型T应该是一个数字类型，所以是我们在接口中声明的任何类型。然后，像以前一样我们声明一个函数，只不过我们用T代替了int。
如果新的函数现在被调用，Go会检查用户提供的类型是否符合接口的要求。如果是的话，它将在整个函数中用该类型替换Tw。因此，如果我们输入一个int类型的数字，我们也会得到一个整数的回报。如果我们输入一个float64，我们将得到一个float64的返回值，以此类推。因此，我们现在有了一个单一的 &amp;ldquo;全能 &amp;ldquo;函数，而不是写12个内容完全相同的函数，但对Go中的每个数字类型都有不同的参数类型。</description></item><item><title>Kubernetes中Go服务的远程debug</title><link>https://lixianwa.github.io/posts/kubernetes%E4%B8%ADgo%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%9C%E7%A8%8Bdebug/</link><pubDate>Tue, 07 Dec 2021 20:01:09 +0800</pubDate><guid>https://lixianwa.github.io/posts/kubernetes%E4%B8%ADgo%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%9C%E7%A8%8Bdebug/</guid><description>&lt;p>作为开发人员，我们总是会遇到一些bug本地无法模拟，需要在通过远程方式排查，本教程介绍如何配置远程debug Kubernetes上的Go服务，通过本教程，你会学到：&lt;/p>
&lt;ul>
&lt;li>通过dlv工具远程debug 用Go写的服务&lt;/li>
&lt;li>vscode配置远程debug&lt;/li>
&lt;/ul></description></item><item><title>Dapr中的Actor模型</title><link>https://lixianwa.github.io/posts/dapr%E4%B8%AD%E7%9A%84actor%E6%A8%A1%E5%9E%8B/</link><pubDate>Thu, 22 Apr 2021 21:12:55 +0800</pubDate><guid>https://lixianwa.github.io/posts/dapr%E4%B8%AD%E7%9A%84actor%E6%A8%A1%E5%9E%8B/</guid><description>&lt;p>原文链接：https://docs.dapr.io/developing-applications/building-blocks/actors/actors-overview/&lt;/p>
&lt;h2 id="介紹">介紹&lt;/h2>
&lt;p>Actor模型将Actor描述为最低层次的 &amp;ldquo;计算单元&amp;rdquo;。换句话说，你把代码写在一个独立的单元（称为Actor）中，这个单元每次接收消息并处理它们，没有任何并发或线程。&lt;/p>
&lt;p>当你的代码处理一条消息时，它可以发送一条或多条消息给其他Actor，或者创建新的Actor。底层运行时管理每个Actor的运行方式、时间和地点，并在角色之间路由消息。&lt;/p>
&lt;p>大量的actor可以同时执行，而且actor之间可以独立执行。&lt;/p>
&lt;p>Dapr包括一个专门实现虚拟Actor模式的运行时。通过Dapr的实现，你可以根据Actor模式编写Dapr的actors，Dapr利用底层平台提供可扩展性和可靠性保证。&lt;/p></description></item><item><title>Arthas反编译更新线上代码</title><link>https://lixianwa.github.io/posts/arthas%E5%8F%8D%E7%BC%96%E8%AF%91%E6%9B%B4%E6%96%B0%E7%BA%BF%E4%B8%8A%E4%BB%A3%E7%A0%81/</link><pubDate>Mon, 12 Apr 2021 15:22:37 +0800</pubDate><guid>https://lixianwa.github.io/posts/arthas%E5%8F%8D%E7%BC%96%E8%AF%91%E6%9B%B4%E6%96%B0%E7%BA%BF%E4%B8%8A%E4%BB%A3%E7%A0%81/</guid><description>&lt;p>很多时候，出现线上问题，我们需要紧急修复程序并立马生效，使线上问题影响最小，所以我们需要线上更新部分程序，今天就以热更新com.example.demo.arthas.user.UserController为例，介绍Arthas工具如何热更新线上代码。&lt;/p>
&lt;h4 id="1-下载arthas工具并运行">1. 下载arthas工具并运行&lt;/h4>
&lt;pre>&lt;code>curl -O https://arthas.aliyun.com/arthas-boot.jar
java -jar arthas-boot.jar
&lt;/code>&lt;/pre></description></item><item><title>Jupyter Notebook添加conda环境</title><link>https://lixianwa.github.io/posts/jupyter-notebook%E6%B7%BB%E5%8A%A0conda%E7%8E%AF%E5%A2%83/</link><pubDate>Sat, 27 Jun 2020 10:47:30 +0800</pubDate><guid>https://lixianwa.github.io/posts/jupyter-notebook%E6%B7%BB%E5%8A%A0conda%E7%8E%AF%E5%A2%83/</guid><description>&lt;p>本篇博客介绍如何将conda中python环境添加到Jupyter notebook中.&lt;/p>
&lt;h3 id="1-安装ipykernel">1. 安装ipykernel&lt;/h3>
&lt;pre>&lt;code>conda install ipykernel
&lt;/code>&lt;/pre></description></item><item><title>如何修改mongo文档中数组元素的内容</title><link>https://lixianwa.github.io/posts/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9mongo%E6%96%87%E6%A1%A3%E4%B8%AD%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%86%85%E5%AE%B9/</link><pubDate>Mon, 30 Mar 2020 10:46:50 +0800</pubDate><guid>https://lixianwa.github.io/posts/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9mongo%E6%96%87%E6%A1%A3%E4%B8%AD%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%86%85%E5%AE%B9/</guid><description>&lt;p>在平时开发中，我们可能会遇到修改mongodb文档数组里边元素的值，那如何修改数组中元素的值呢? 其实mongodb 提供了update set指令，
可以实现我们的需求，具体如下：&lt;/p>
&lt;p>比如，我们的文档格式如下：&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;categories&amp;quot;: [&amp;quot;新闻&amp;quot;，&amp;quot;图片&amp;quot;]
}
&lt;/code>&lt;/pre></description></item><item><title>基于v2ray的科学上网服务器搭建</title><link>https://lixianwa.github.io/posts/%E5%9F%BA%E4%BA%8Ev2ray%E7%9A%84%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</link><pubDate>Tue, 18 Jun 2019 10:46:18 +0800</pubDate><guid>https://lixianwa.github.io/posts/%E5%9F%BA%E4%BA%8Ev2ray%E7%9A%84%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</guid><description>&lt;h2 id="一-服务器配置">一. 服务器配置&lt;/h2>
&lt;ul>
&lt;li>阿里云香港&lt;/li>
&lt;li>1Core&lt;/li>
&lt;li>25G&lt;/li>
&lt;li>限速30Mps&lt;/li>
&lt;li>ubuntu 16.04&lt;/li>
&lt;/ul></description></item><item><title>“机器学习通用工作流程”</title><link>https://lixianwa.github.io/posts/ml-general-workflow/</link><pubDate>Mon, 10 Jun 2019 19:30:22 +0800</pubDate><guid>https://lixianwa.github.io/posts/ml-general-workflow/</guid><description>&lt;p>机器学习的通用工作流程总结为如下几个步骤：&lt;/p>
&lt;h3 id="1---定义问题收集数据集">1. 定义问题，收集数据集&lt;/h3>
&lt;p>首先我们必须先定义多面对的问题。&lt;/p>
&lt;ol>
&lt;li>输入的数据是什么？你要预测什么？&lt;/li>
&lt;li>你面对的是什么类型的问题？二分类问题、多分类问题、标量回归问题&lt;br>
向量回归问题还是其他问题，确定问题类型，有助于选择模型架构，损失函数。&lt;br>
同时做出如下&lt;code>假设&lt;/code>：&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>假设输出可以根据输入进行预测&lt;/li>
&lt;li>假设可用数据包含足够多的信息，足以学习输入和输出之间的关系&lt;/li>
&lt;/ul></description></item><item><title>Pandas</title><link>https://lixianwa.github.io/posts/pandas/</link><pubDate>Wed, 10 Apr 2019 22:58:49 +0800</pubDate><guid>https://lixianwa.github.io/posts/pandas/</guid><description>&lt;h3 id="pandas-速查手册">Pandas 速查手册&lt;/h3>
&lt;p>对于数据科学家，无论是数据分析还是数据挖掘，如果用 Python作为工具，Pandas是一个非常重要的Python包，它不仅提供了很多方法，是的数据处理变得非常简单，同时由于底层使用Numpy，使得数据处理的速度也很快，比Python内置的方法有很大优势。&lt;/p>
&lt;h4 id="pandas包导入">Pandas包导入&lt;/h4>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">import&lt;/span> pandas &lt;span style="color:#f92672">as&lt;/span> pd
&lt;span style="color:#f92672">import&lt;/span> numpy &lt;span style="color:#f92672">as&lt;/span> np
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Swift条件展开初始化</title><link>https://lixianwa.github.io/posts/conditional-unwrapping-initialization/</link><pubDate>Tue, 06 Sep 2016 00:00:00 +0000</pubDate><guid>https://lixianwa.github.io/posts/conditional-unwrapping-initialization/</guid><description>&lt;p>原文链接：&lt;a href="http://ericasadun.com/2016/08/04/idiomatic-swift-conditional-unwrapping-initialization/">Idiomatic Swift: conditional unwrapping initialization&lt;/a>&lt;/p>
&lt;p>Swift-Users上，Dan T 问：&lt;br>
目前我这样写：&lt;/p>
&lt;pre>&lt;code>let dobString: String
if let dob = dob {
dobString = serverDateFormatter.stringFromDate(dob)
}
else {
dobString = &amp;quot;&amp;quot;
}
&lt;/code>&lt;/pre>&lt;p>有没有更好，更通用的方法实现同样的功能？&lt;/p></description></item><item><title>如何使用curl进行http请求</title><link>https://lixianwa.github.io/posts/how-to-use-curl/</link><pubDate>Thu, 01 Sep 2016 00:00:00 +0000</pubDate><guid>https://lixianwa.github.io/posts/how-to-use-curl/</guid><description>&lt;p>如今的互联网时代，我们在日常开发中经常需要测试HTTP[S] API，有一些含用户界面的工具使用很方便，如Chrome插件Postman等。 但作为码农的我们有时候会觉得带图形的东西还不如命令行下敲一段命令来的简便，今天介绍一款可以在命令行下测试API的工具curl。&lt;/p></description></item><item><title>ReactiveCocoa中的基本算子</title><link>https://lixianwa.github.io/posts/basic-operators/</link><pubDate>Sun, 14 Aug 2016 00:00:00 +0000</pubDate><guid>https://lixianwa.github.io/posts/basic-operators/</guid><description>&lt;p>原文链接: &lt;a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/BasicOperators.md">Basic Operators&lt;/a>&lt;/p>
&lt;p>这个文档解释ReactiveCocoa中最常用的Operator，以及一些用例。注意Operators，在这里指的是signal和signal producers之间的转换，不是Swift中的操作符，换句话说，这些是ReactiveCocoa提供处理事件流的组合原语。该文档使用术语“事件流”来描述Signal和SignalProducer的概念。&lt;/p>
&lt;h3 id="事件流副作用">事件流副作用&lt;/h3>
&lt;h4 id="观察observation">观察（Observation）&lt;/h4>
&lt;p>Signal可以被观察通过observe函数，需要一个Observer作为参数，任何事件流都会发送给它。&lt;/p>
&lt;pre>&lt;code>signal.observe(Signal.Observer { event in
switch event {
case let .Next(next):
print(&amp;quot;Next: \(next)&amp;quot;)
case let .Failed(error):
print(&amp;quot;Failed: \(error)&amp;quot;)
case .Completed:
print(&amp;quot;Completed&amp;quot;)
case .Interrupted:
print(&amp;quot;Interrupted&amp;quot;)
}
})
&lt;/code>&lt;/pre></description></item><item><title>&lt;&lt;自控力>>读书笔记</title><link>https://lixianwa.github.io/posts/%E8%87%AA%E6%8E%A7%E5%8A%9B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link><pubDate>Fri, 20 May 2016 00:00:00 +0000</pubDate><guid>https://lixianwa.github.io/posts/%E8%87%AA%E6%8E%A7%E5%8A%9B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid><description>&lt;h3 id="一-意志力是什么">一. 意志力是什么？&lt;/h3>
&lt;p>&lt;strong>意志力其实是“我要做”，“我不要”和“我想要”这三种力量。&lt;/strong>&lt;/p>
&lt;p>深入剖析:&lt;/p>
&lt;ul>
&lt;li>更难的事是什么？想象你正面临一个意志力挑战，更难的事是什么？它为什么这么困难？&lt;/li>
&lt;li>认清两个自我。你的意志力挑战是，如何描述想抗衡的两个自我？冲动的你想要什么？明智的你想要什么？&lt;/li>
&lt;/ul>
&lt;p>意志力实验:&lt;/p>
&lt;ul>
&lt;li>记录你的意志力选择。至少一天，注意观察你做的关于意志力的决定。&lt;/li>
&lt;li>5分钟大脑训练冥想。在脑海中默念“呼”和“吸”，把注意力集中在呼吸上。
当你走神的时候，重新集中注意力。&lt;/li>
&lt;/ul></description></item><item><title>Xcode-keyboard-shortcuts</title><link>https://lixianwa.github.io/posts/xcode-keyboard-shortcuts/</link><pubDate>Thu, 10 Mar 2016 00:00:00 +0000</pubDate><guid>https://lixianwa.github.io/posts/xcode-keyboard-shortcuts/</guid><description>Xcode提供很多快捷键，我们不可能都记住，但平时的开发中如果能尽可能多的使用快捷键，效率会提高不少，下面总结了Xcode的一些常用快捷键：
快捷键 功能 星级 command + shift + O 打开搜索窗口 ＊＊＊＊＊ command + 0 显示／隐藏导航区 ＊＊＊＊＊ command + 1~n 选择不同的导航器 ＊＊＊＊ command + option + J 过滤导航结果 ＊＊＊ command + shift + Y 显示／隐藏调试区 ＊＊＊＊ command + option + 0 显示／隐藏实用工具区选项卡 ＊＊＊ command + option + 1~n 切换使用工具区选项卡 ＊＊＊ control + 6 方法跳转菜单 ＊＊＊＊ control + command + Up／Down 对应文件导航 ＊＊＊＊ control + command + Left／Right 查看历史文件 ＊＊＊＊＊ control + command + E 重构符 ＊＊＊＊＊ control + command + J 查看符号来源 ＊＊＊ command + shift + ]／[ 移动到上一个／下一个标签 ＊＊＊＊＊ command + option + ]／［ 整行代码上／下移动 ＊＊＊ command + R 运行应用 ＊＊＊＊＊ command + B 构建应用 ＊＊＊＊＊ control + .</description></item><item><title>如何解决retain cycle</title><link>https://lixianwa.github.io/posts/the-solution-of-retain-cycle/</link><pubDate>Wed, 28 Oct 2015 00:00:00 +0000</pubDate><guid>https://lixianwa.github.io/posts/the-solution-of-retain-cycle/</guid><description>当遇到retain cycle是，一般我们的解决办法是让一个变为weak reference，而选择让那个变成weak reference是个问题。 我们可以把存在retain cycle的两个对象看成是 父－子 关系。 在这个关系当中，父可以拥有子，但是子不可以拥有父，因此，在这个问题中，我们可以把作为 父 的对象定义为strong， 而作为 子 的对象定义为weak，这样就解决了retain cycle。</description></item><item><title>一个iOS View crash问题</title><link>https://lixianwa.github.io/posts/an-ios-view-crash-error/</link><pubDate>Thu, 15 Oct 2015 00:00:00 +0000</pubDate><guid>https://lixianwa.github.io/posts/an-ios-view-crash-error/</guid><description>[2015-10-15] 用xib做了一个简单的界面，程序启动时会crash掉，xcode error打印信息：
Terminating app due to uncaught exception &amp;lsquo;UIViewControllerHierarchyInconsistency&amp;rsquo;, reason: &amp;lsquo;A view can only be associated with at most one view controller at a time! View &amp;lt;UIView: 0x7f914af22610; frame = (0 0; 414 736); autoresize = W+H; layer = &amp;lt;CALayer: 0x7f914af22980&amp;raquo; is associated with &amp;lt;UIViewController: 0x7f914ae49a90&amp;gt;. Clear this association before associating this view with &amp;lt;TestViewController: 0x7f914ac7f680&amp;gt;.&amp;rsquo;</description></item><item><title>开始使用hexo生成blog</title><link>https://lixianwa.github.io/posts/blog-from-jekyll-to-hexo/</link><pubDate>Tue, 13 Oct 2015 00:00:00 +0000</pubDate><guid>https://lixianwa.github.io/posts/blog-from-jekyll-to-hexo/</guid><description>hello, hexo ！</description></item><item><title>markdown语法</title><link>https://lixianwa.github.io/posts/markdown%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 12 Oct 2015 00:00:00 +0000</pubDate><guid>https://lixianwa.github.io/posts/markdown%E8%AF%AD%E6%B3%95/</guid><description>本文转自这里
使用 Markdown 真的可以写出非常整洁的文档来，看到很多人都在使用，自己也忍不住学习了下。网上有很多讲解 markdown 语法的，资料庞大复杂不够简练，学个基础语法置于这么麻烦么。我做了一些整理，保证你学了这些，就可以使用 markdown 去秀文档了。
1、标题： #h1级标题 ##h2级标题 ###h3级标题 ####h4级标题 #####h5级标题 ######h6级标题 2、分割线：三个以上的短线 即可作出分割线(需要空行隔开生效) 3、超链接：[连接名称](网址 , 标题) [我是链接名](http://www.izhangbo.cn, “我是标题”) [&amp;lt;i class=”icon-refresh”&amp;gt;&amp;lt;/i&amp;gt; 点我刷新](/sonfilename/) 另一种超链接写法：[链接名][链接代号] [here][3] 然后在别的地方定义 3 这个详细链接信息，[3]: http://www.izhangbo.cn “haode” 4、键盘键 &amp;lt;kbd&amp;gt;Ctrl+[&amp;lt;/kbd&amp;gt; and &amp;lt;kbd&amp;gt;Ctrl+]&amp;lt;/kbd&amp;gt; 5、code格式：反引号 Use the `printf()` function. “There is a literal backtick (`) here.针对在代码区段内插入反引号的情况“ 6、强调： *斜体强调* **粗体强调** 7、图片 ![Alt text](/path/to/img.jpg “Optional title”) 8、上角标 这里加个上角标[^stackedit] [^stackedit]:角标内容详情 9、使用 icon 图标文字 &amp;lt;i class=”icon-cog”&amp;gt;&amp;lt;/i&amp;gt; 10、段落：以一个空行开始，以一个空行结束，中间的就是一个段落。 11、表格：这个稍微有些复杂 Item | Value ——– | — Computer | $1600 Phone | $12 Pipe | $1 12、无序列表：使用 – 加一个空格(需要空行隔开生效) – 无需列表1 – 无序列表2 – 无序列表3 13、有序列表：使用 数字 加一个英文句点(需要空行隔开生效) 1.</description></item><item><title>工具</title><link>https://lixianwa.github.io/posts/2015-03-14-tools/</link><pubDate>Mon, 12 Oct 2015 00:00:00 +0000</pubDate><guid>https://lixianwa.github.io/posts/2015-03-14-tools/</guid><description>工具 jira:项目与事务跟踪工具，被广泛应用于缺陷跟踪、客户服务、需求收集、流程审批、任务跟踪、项目跟踪和敏捷管理等工作领域. confluence:企业知识管理与协同软件，也可以用于构建企业wiki。 GitLab:基于Git的开源项目，客用于搭建私有的Github。 Riemann:报警系统，函数式编程语言clojure编写，可配置性强，可以和OpenTSDB等时间序列存贮系统结合，构建企业报警系统。</description></item><item><title>统一账户管理系统RESTful api设计</title><link>https://lixianwa.github.io/posts/2015-04-10-ldapadmin-design/</link><pubDate>Fri, 10 Apr 2015 00:00:00 +0000</pubDate><guid>https://lixianwa.github.io/posts/2015-04-10-ldapadmin-design/</guid><description>LDAPAdmin, 为用户管理提供一组API，以HTTP-based RESTful API的形式提供服务，提供了对ldap数据的增删改查功能。主要用到了HTTP的四种方法：GET， POST， PUT和 DELETE。
下面主要对LDAPAdmin 的REST Api做个简单介绍：
##Functionality ###Terminology ###User stories
利用该组件的HTTP API，通过提交一组描述 用户／部门／系统／管理员的JSON数据，添加、删除、更新、查询数据； 利用该组件的HTTP API，可以方便的添加一条 用户／部门／系统／管理员记录； 利用该组件的HTTP API，可以方便的更新一条指定的 用户／部门／系统／管理员记录； 利用该组件的HTTP API，可以方便的将指定的 用户／部门／系统／管理员删除； ###Scope and Non-Scope ####Scope
用户／部门／系统／管理员 信息相关数据的添加、更新、删除； 查询 用户／部门／系统／管理员的信息； 用户／部门／系统／管理员 的有效性； ###Non-Scope
用户数据的可靠性，数据由管理员负责维护 ##Low-level Design ###Response Code
Code Remind Description 200 OK – [GET] 成功返回用户请求的数据 201 CREATED – [POST/PUT] 新建/修改数据成功 204 NO CONTENT – [DELETE] 删除数据成功 400 INVALID REQUEST – [POST/PUT 用户发出请求有误，服务器没有新建/修改数据 401 Unauthorized – [*] token认证失败，token过期等情况 403 Forbidden – [*] 用户认证成功，但没有权限进行相应操作（权限细分） 404 NOT FOUND – [*] 请求的资源（在这里是表、字段不存在等情况） 406 NOT Acceptable – [GET] 用户请求的格式不可得 500 INTERNAL SERVER ERROR – [*] 服务器内部错误，用户无法判断请求是否成功 ###Response| Result #####除了每个响应都携带的返回码和可选的description字段，以下为该API的返回结果（具体形式在每种请求中都有举例）：</description></item><item><title>关于sizeof</title><link>https://lixianwa.github.io/posts/2014-07-09-about-sizeof/</link><pubDate>Wed, 09 Jul 2014 00:00:00 +0000</pubDate><guid>https://lixianwa.github.io/posts/2014-07-09-about-sizeof/</guid><description>前两天犯了一个愚蠢的错误，由于对sizeof理解的错误，导致代码出现了一个bug,具体代码逻辑如下：
char buf[512]; char *ptr; int size; ptr = buf; size = sizeof(ptr); 本来是计算buf的大小，但这样写其实只是得到 char指针类型的大小，错误的以为ptr指向buf时，用sizeof获取的也是buf的大小。通过了解，如果sizeof的操作数为指针时，不管指针指向什么类型，值都是指针类型的大小，32位系统为4.具体sizeof的结果如下：　1、当操作数为数据类型时，所得结果为给数据类型的大小。如：32bit系统上，sizeof（char）＝ 1　，sizeof（int） ＝ 4。
2、当操作数是指针时，sizeof依赖于编译器。例如Microsoft　C/C++7.0中，near 类指针字节数为2，far、huge类指针字节数为4。一般Unix的指针字节数为4。　3、当操作数具有数组类型时，其结果是数组的总字节数。　4、联合类型操作数的sizeof是其最大字节成员的字节数。结构类型操作数的 sizeof是这种类型对象的总字节数，包括任何垫补在内。　让我们看如下结构：　struct　{ char　b; double　x; }　a;　在某些机器上sizeof（a）=12，而一般sizeof（char）+　sizeof（double）= 9。 这是因为编译器在考虑对齐问题时，在结构中插入空位以控制各成员对象的地址对 齐。如double类型的结构成员x要放在被4整除的地址。　5、如果操作数是函数中的数组形参或函数类型的形参，sizeof给出其指针的大小。</description></item><item><title>安装archlinux</title><link>https://lixianwa.github.io/posts/2014-04-26-install-archlinux/</link><pubDate>Sat, 26 Apr 2014 00:00:00 +0000</pubDate><guid>https://lixianwa.github.io/posts/2014-04-26-install-archlinux/</guid><description>活着就是为了折腾，Ubuntu已经用了4年多了吧，从最近几年看来，ubuntu的发展目的是要面向大众化，由于要适合大众，所以他的操作更简单，图形界面更美观，这就导致它越来越笨重。对于一个追求速度，喜欢命令模式的程序猿，ubuntu已然不能满足我的要求，所以安装archlinux的想法产生了，活着不就是为了折腾嘛，于是一步一步定制专属自己的linux系统。
1.下载archlinux镜像文件 2.制作usb安装盘
# dd bs=4M if=&amp;lt;/archlinux-2014.04.01-dual.iso/的/路径&amp;gt; of=/dev/&amp;lt;U盘文件&amp;gt; &amp;amp;&amp;amp; sync 3.从U盘启动选择Boot Arch Linux 4.配置安装 1)连接网络 有线连接：
# dhcpcd 无线连接：
# wifi-menu ADSL 宽带连接： 配置：
# pppoe-setup 连接：
# systemctl start adsl 2)选择软件源
# vi /etc/pacman.d/mirrorlist 更新本地数据库： # pacman -Syy 5.分区 1)分区方案：
$ lsblk /dev/sda -o NAME,FSTYPE,SIZE,MOUNTPOINT NAME FSTYPE SIZE MOUNTPOINT sda 120G ├─sda1 ext4 36G / ├─sda2 ext4 80G /home └─sda3 swap 4G [SWAP] 注意：swap分区大小建议等于或两倍于内存。 2)分区： MBR 分区：</description></item><item><title>关于开源软件redis</title><link>https://lixianwa.github.io/posts/2014-04-04-about-redis/</link><pubDate>Fri, 04 Apr 2014 00:00:00 +0000</pubDate><guid>https://lixianwa.github.io/posts/2014-04-04-about-redis/</guid><description>最近读redis代码，redis是一个key-value存储系统,详情请看官网介绍redis，仅2万多行代码，实现如此强大的 功能，真是让人不由的惊叹！而且代码是非常之漂亮, 《redis设计与实现》可以帮助你了解redis 的具体实现，redis的github地址。</description></item><item><title>nginx编译报错</title><link>https://lixianwa.github.io/posts/2014-04-10-install-nginx-on-ubuntu/</link><pubDate>Mon, 24 Mar 2014 00:00:00 +0000</pubDate><guid>https://lixianwa.github.io/posts/2014-04-10-install-nginx-on-ubuntu/</guid><description>在ubuntu(32bit)上安装nginx执行configure时遇到错误如下：
./configure: error: the HTTP rewrite module requires the PCRE library. You can either disable the module by using --without-http_rewrite_module option, or install the PCRE library into the system, or build the PCRE library statically from the source with nginx by using --with-pcre=&amp;lt;path&amp;gt; option. 貌似缺少pcre库，在网上搜了，说是需要安装pcre-devel,可是ubuntu上安装是找不到pcre-devel。 可能是名字变了，后来终于找到解决办法，需要安装 libpcre3 libpcre3-dev：
# sudo apt-get install libpcre3 libpcre3-dev</description></item><item><title>横琴岛游记</title><link>https://lixianwa.github.io/posts/2014-03-24-cycling-to-hengqin/</link><pubDate>Mon, 24 Mar 2014 00:00:00 +0000</pubDate><guid>https://lixianwa.github.io/posts/2014-03-24-cycling-to-hengqin/</guid><description>每次游玩回来，或多或少总会有那么一些感想,而这次感触颇深，也许与我最近的心 情有关吧。从小到大，语文一直不好，因此而没少挨老师的批，以至于现在坐在电脑前 想写点东西的时候，总感觉缺少一些词藻，把心里的想法和感受用语言这种奇怪的东西表 达出来。犹豫了许久，决定还是把它记下来吧，也许二十年、三十年或者更老，记不起事 的时候翻出来看看，也许能勾起对年轻时的回忆,也不失为一件美好的事！再说对于我这种 记性不是很好的动物来说,记下来总归是安全的。
最近心情一直不怎么好，可能是这段时间工作上的事少，我这人有点贱，一闲下来就 有点不淡定，容易想一些乱七八糟的事情，一想就郁闷。什么结婚啊、买房啊，最近听这些 话题太多太多了,听多了不由的让人不想啊,唉！平时由于工作忙，没有太多时间去想这些, 其实我压根不愿意想去这些事情，总抱着一种该来的总会来的态度。
昨天一同事说打算骑自行车去横琴岛玩，问我去不去，想了想去就去呗，反正也没啥坏处， 还可以锻炼下身体，减减肥肉，说不定还会有一些意外的收获，何乐而不为。就是可 怜了我那坐骑,跟随了我大半年时间，最近老是咯吱咯吱响，不知道还能不能坚持下来，要 是在半路上罢工，那就麻烦啦。
早上十点从家里出发，路边随便买了点早餐，按照提前约好的时间来到华发广场集合， 一行总共六人。天气特给力，不冷不热，偶尔还有点微风，真是出去玩的好时间。蹬着单车， 微风从脸颊吹过，那感觉就一个字“爽”！有点可惜的是自行车后刹车不灵，一路上不敢骑 太快，单怕和那些奔驰宝马亲吻一下。
大约两个小时，到了横琴，又累又饿，也到了午饭的时候，路边找了家快餐店，随便点了份 快餐和一杯奶茶，我勒个去，奶茶杯怎么那么旧，感觉很脏似的，不过那快餐还是蛮好吃的， 或许是饿了的缘故吧，大家狼吞虎咽地几下吃完了，然后稍微坐了一会，又开始出发了，直 奔海边。
沿着海边有一条很长的水泥路，两边有护栏，路很平坦，毫无遮挡,一路飞奔,真是爽歪了! 到了海边，大家一起合了个影，帮我们照相的是一中年大叔，那大叔蛮有意思，照完之后他拿着我 手机摆出个姿势，示意要扔给我，我还以为这大叔发疯了,急忙一边跑一边喊“别别别， 我接不住”，后来大叔笑着给我手机，说“我跟你开个玩笑而已，我怎么会扔呢”，呵呵,是 我想多了.在海边碰到一小伙，跟我年龄差不多，聊了几句，说是专门过来看海， 却没看到蓝色的大海，有点遗憾。卷起裤腿,跑到水里时,突然一个浪过来,悲剧啊,裤子全湿了. 在海边,微风吹过,听着海浪的声音,心情一下子舒畅了好多，所有负担、所有不愉快的 事统统抛到九霄云外,全身感觉格外的轻松!要是再有一个心爱的姑娘一起,那就完美了.
转眼四点多了,该回去了,我们没有原路返回,本来打算找一条近路,结果长隆隧道不让自行车走,我去,摩托车 让通过,就是不让自行车走,要我说直接冲过去得类,反正那守卫也没有车,肯定追不上.可另外一哥们太 谨慎了,不同意.我们只好再寻找路线了.接着就悲剧更悲剧了,一路上都在修路,坑坑洼洼还是小事, 关键土太厚了,一辆大车过去,整个人感觉被土埋了,人没老,头发先变白了.有种回到老家的感觉. 这一路就不太爽了,坑坑洼洼的人家新车可以很轻松的骑过去,我那破车咋整也骑不快,一路他们一直都 在等我,搞得我都有些不好意思,更不幸的是不小心摔到,腿上刮掉一层皮,还好,谁叫咱是土生土长的农村人, 这点小伤算个屁,站起来拍拍屁股继续走着.
晚上八点多才到市区,大家都饿坏了,突然路边冒出一家酱饼小摊,刚出锅的实在是太好吃了,没想到珠海 还有这货,真是太让人意外了,想想还是在大学时吃过,差不多两年没见过这玩意了.最后找了家饭馆,吃完饭 各回各家,该干嘛干嘛!
回到家坐下来想想,这次出去还是蛮有意思的.我想当时如果不去的话,这一天就在家睡觉啊什么的,同样会过去, 然后感叹,唉!周末就这样过去了.人生也一样,不能老是处在当时没做,过了后悔这种无限循环中.跟着心走,想 做就做,这样即使到死的时候,也不会因当初错过而后悔.</description></item><item><title>内存死机问题</title><link>https://lixianwa.github.io/posts/2014-03-10-crash-about-memory/</link><pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate><guid>https://lixianwa.github.io/posts/2014-03-10-crash-about-memory/</guid><description>最近遇到一个内存导致死机的问题，这种问题总是让人很恼火。
Mstar linux方案，由于对指针的检测不够完善，导致使用了空指针。一个问题整了我一天多时间， 最后查出来尽然是珠海有线的码流里边有一个bouquet id是 -256，而代码里边没有处理到这种情况，获取到空指针， 而在使用的时候又没有检测。幸亏有gdb可以用，可以定位到是那个模块出了问题。完了想想本来这个问题要不 了那么长时间，一开始感觉这个变量有点问题，可就被脑子里那种 &amp;ldquo;不可能这儿出问题啊&amp;quot;的想法打消了，也许 很多程序员会犯这种错误，总是很确信的说&amp;quot;这个不可能&amp;rdquo;，难道这个真的不可能吗？其实自己也不知道，不知道 从哪儿来的这种莫名其妙的自信。 由这个问题想到：
1)不要轻易做任何假设，负责可能会影响你做出准确的判断。
2)时时刻刻在使用指针时要检测是否为空，这个构建健壮软件的必要条件。
3)要让程序能经得起一些意味发生的情况，比如获取到错误变量等。</description></item><item><title>Hello World</title><link>https://lixianwa.github.io/posts/hello-world/</link><pubDate>Sun, 02 Mar 2014 00:00:00 +0000</pubDate><guid>https://lixianwa.github.io/posts/hello-world/</guid><description>Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick Start Create a new post $ hexo new &amp;#34;My New Post&amp;#34; More info: Writing
Run server $ hexo server More info: Server
Generate static files $ hexo generate More info: Generating
Deploy to remote sites $ hexo deploy More info: Deployment</description></item><item><title>提问的智慧</title><link>https://lixianwa.github.io/posts/2014-03-02-smart-questions/</link><pubDate>Sun, 02 Mar 2014 00:00:00 +0000</pubDate><guid>https://lixianwa.github.io/posts/2014-03-02-smart-questions/</guid><description>作为一个技术人员，在学习和工作中，经常会遇到各种各样的问题，有时候我们没法解答的时候？也许最好的办法就是去 求助与他人，不管是通过网络，还是面对面的方式。 于是如何问问题就变的尤为重要，下面这篇 How to Ask Questions The Smart Way会给你答案，相信看完之后你会有很大收获。</description></item><item><title>开始我的博客之旅</title><link>https://lixianwa.github.io/posts/2014-02-26-startup-my-blog/</link><pubDate>Wed, 26 Feb 2014 00:00:00 +0000</pubDate><guid>https://lixianwa.github.io/posts/2014-02-26-startup-my-blog/</guid><description>目的 有人曾说，其实每个人都有好的想法，只是我们当中的大多数人不善于跟踪它而已，此博客主要记录平时的一些想法， 一些技术问题以及分享一切美好的人和事&amp;hellip;
为什么使用 github pages &amp;amp; jekyll 来创建博客 昨天突然兴起，想创建一个属于自己的博客，于是就在google上搜索如何创建自己博客之类的话题， 搜到一篇写的非常详细的博文 搭建一个免费的，无限流量的Blog&amp;mdash;-github Pages和Jekyll入门，免费而且无限流量，太符合我的需求了（是不是有点贱），于是就有了此博。
主题 此博客的主题是在Michael Rose的 Minimal Mistakes主题的基础上修改的，在此感谢Michael Rose！</description></item></channel></rss>