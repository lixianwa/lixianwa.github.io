<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><title>在Kubernetes上gRPC是如何通过Headless Service负载均衡 | Lionel's Blog</title><link href=/favicon.ico rel="shortcut icon" type=image/x-icon><meta name=author content="归零"><meta name=description content="gRPC 是用于进程间通信的最流行的现代 RPC 框架之一。 它是微服务架构的绝佳选择。 而且，毫无疑问，部署微服务应用程序最流行的方式是 Kubernetes。
Kubernetes部署可以具有相同的后端实例，为许多客户端请求提供服务。 Kubernetes 的 ClusterIP 服务提供负载均衡的IP地址。 但是这种默认的负载平衡不适用于gRPC开箱即用。
如果你使用gRPC并在 Kubernetes 上部署了许多后端服务，那么本文档适合你。
"><meta name=generator content="Hugo 0.81.0"><link rel=canonical href=https://lixianwa.github.io/posts/%E5%9C%A8kubernetes%E4%B8%8Agrpc%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87headless-service%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/><meta property="og:title" content="在Kubernetes上gRPC是如何通过Headless Service负载均衡"><meta property="og:description" content="gRPC 是用于进程间通信的最流行的现代 RPC 框架之一。 它是微服务架构的绝佳选择。 而且，毫无疑问，部署微服务应用程序最流行的方式是 Kubernetes。
Kubernetes部署可以具有相同的后端实例，为许多客户端请求提供服务。 Kubernetes 的 ClusterIP 服务提供负载均衡的IP地址。 但是这种默认的负载平衡不适用于gRPC开箱即用。
如果你使用gRPC并在 Kubernetes 上部署了许多后端服务，那么本文档适合你。"><meta property="og:type" content="article"><meta property="og:url" content="https://lixianwa.github.io/posts/%E5%9C%A8kubernetes%E4%B8%8Agrpc%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87headless-service%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-20T14:59:52+08:00"><meta property="article:modified_time" content="2021-12-20T14:59:52+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="在Kubernetes上gRPC是如何通过Headless Service负载均衡"><meta name=twitter:description content="gRPC 是用于进程间通信的最流行的现代 RPC 框架之一。 它是微服务架构的绝佳选择。 而且，毫无疑问，部署微服务应用程序最流行的方式是 Kubernetes。
Kubernetes部署可以具有相同的后端实例，为许多客户端请求提供服务。 Kubernetes 的 ClusterIP 服务提供负载均衡的IP地址。 但是这种默认的负载平衡不适用于gRPC开箱即用。
如果你使用gRPC并在 Kubernetes 上部署了许多后端服务，那么本文档适合你。"><link rel=stylesheet href=/css/semantic.min.css><link rel=stylesheet href=/css/icomoon.css><link rel=stylesheet href=/css/OverlayScrollbars.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/site.css><style>a:not(.ui.button):hover{text-decoration:underline}a:not(.ui.button){color:#2e8b57!important}.inverted a:not(.ui.button),.inverted a:not(.ui.button):hover{color:#8fbc8f!important}body.default{background-color:#f7f7f7;background-image:url(/me/background.jpeg)}body.dark{background-color:#000}</style><link rel=stylesheet data-highlight href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/gruvbox-light.min.css><link rel=stylesheet href=/css/custom.css></head><body class=default><nav class="ui secondary menu dream-menu"><div class=item><i class="large link bullseye icon dream-flip-toggle" title=翻转！></i></div><div class=item><i class="large link home icon" title=首页 onclick="window.location.href='https://lixianwa.github.io/'"></i></div><div class=item><i class="large link icon theme-switch" onclick=themeSwitch()></i></div><div class=item><i class="large link search icon" onclick=toggleSearch()></i></div></nav><div class=flip-container><div class=flipper><section class=front><div class=dream-max-width><div class="ui relaxed grid dream-grid dream-grid-single"><aside class="sixteen wide mobile sixteen wide tablet four wide computer column dream-single-aside"><div class="ui segment toc"><nav id=TableOfContents><ul><li><a href=#为什么负载均衡>为什么负载均衡？</a></li><li><a href=#grpc中的负载均衡选项>gRPC中的负载均衡选项</a><ul><li><a href=#代理负载均衡>代理负载均衡</a></li><li><a href=#客户端负载均衡>客户端负载均衡</a></li></ul></li><li><a href=#grpc负载平衡相关的挑战>gRPC负载平衡相关的挑战</a><ul><li><a href=#创建服务端-deployment>创建服务端 Deployment</a></li><li><a href=#创建-service>创建 Service</a></li><li><a href=#创建客户端deployment>创建客户端Deployment</a></li><li><a href=#使用headless-service的客户端负载平衡>使用Headless Service的客户端负载平衡</a></li><li><a href=#什么是-headless-service>什么是 Headless Service?</a></li><li><a href=#验证dns>验证DNS</a></li><li><a href=#配置客户端>配置客户端</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div><div class="ui segment actions"><button class="ui circular icon button save-as-image" title=保存为图片 onclick=savePostAsImg()>
<i class="save icon"></i></button>
<a href="https://twitter.com/intent/tweet?text=%e5%9c%a8Kubernetes%e4%b8%8agRPC%e6%98%af%e5%a6%82%e4%bd%95%e9%80%9a%e8%bf%87Headless%20Service%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1&url=https%3a%2f%2flixianwa.github.io%2fposts%2f%25E5%259C%25A8kubernetes%25E4%25B8%258Agrpc%25E6%2598%25AF%25E5%25A6%2582%25E4%25BD%2595%25E9%2580%259A%25E8%25BF%2587headless-service%25E8%25B4%259F%25E8%25BD%25BD%25E5%259D%2587%25E8%25A1%25A1%2f" class="ui circular twitter icon button"><i class="twitter icon"></i></a><a href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flixianwa.github.io%2fposts%2f%25E5%259C%25A8kubernetes%25E4%25B8%258Agrpc%25E6%2598%25AF%25E5%25A6%2582%25E4%25BD%2595%25E9%2580%259A%25E8%25BF%2587headless-service%25E8%25B4%259F%25E8%25BD%25BD%25E5%259D%2587%25E8%25A1%25A1%2f" class="ui circular facebook icon button"><i class="facebook icon"></i></a></div></aside><div class="sixteen wide mobile sixteen wide tablet twelve wide computer column markdown-body dream-single" id=dream-save-post-as-img><section class="ui attached segment"><header><h1 class="ui large header">在Kubernetes上gRPC是如何通过Headless Service负载均衡<div class="sub header">@
归零
|
星期一，十二月 20 日，2021 年
| 3 分钟阅读
| 更新于
星期一，十二月 20 日，2021 年</div></h1></header><article class=main><p>gRPC 是用于进程间通信的最流行的现代 RPC 框架之一。 它是微服务架构的绝佳选择。 而且，毫无疑问，部署微服务应用程序最流行的方式是 Kubernetes。</p><p>Kubernetes部署可以具有相同的后端实例，为许多客户端请求提供服务。 Kubernetes 的 ClusterIP 服务提供负载均衡的IP地址。 但是这种默认的负载平衡不适用于gRPC开箱即用。</p><p>如果你使用gRPC并在 Kubernetes 上部署了许多后端服务，那么本文档适合你。</p><h2 id=为什么负载均衡>为什么负载均衡？</h2><p>一个大规模的部署有许多相同的后端实例和许多客户。每个后端服务器都有一定的容量。负载均衡用于将客户端的负载分配到可用的服务器上。</p><p>在你开始详细了解Kubernetes中的gRPC负载均衡之前，让我们试着了解一下负载均衡的好处是什么。
负载均衡有很多好处，其中一些是。</p><ul><li>容错：如果你的副本之一出现故障，则其他服务器可以为请求提供服务。</li><li>提高可扩展性：你可以将用户流量分布在多台服务器上，从而提高可扩展性。</li><li>提高吞吐量：你可以通过在各种后端服务器之间分配流量来提高应用程序的吞吐量。</li><li>无停机部署：你可以使用滚动部署技术实现无停机部署。</li></ul><h2 id=grpc中的负载均衡选项>gRPC中的负载均衡选项</h2><p>gRPC 中有两种类型的负载均衡：</p><ul><li>代理</li><li>客户端</li></ul><h3 id=代理负载均衡>代理负载均衡</h3><p>在代理负载平衡中，客户端向负载平衡器(LB)代理发出 RPC。 LB 将 RPC 调用分发到可用的后端服务器之一，这些后端服务器实现了为调用提供服务的实际逻辑。 LB 跟踪每个后端的负载并实现公平分配负载的算法。客户端本身不知道后端服务器。客户可能不受信任。这种架构通常用于面向用户的服务，其中来自开放互联网的客户端可以连接到服务器</p><h3 id=客户端负载均衡>客户端负载均衡</h3><p>在客户端负载均衡中，客户端知道许多后端服务器，并为每个 RPC 选择一个使用。如果客户端希望它可以根据来自服务器的负载报告来实现负载平衡算法。对于简单的部署，客户端可以在可用服务器之间循环请求。
有关 gRPC 负载平衡选项的更多信息，您可以查看文章 <a href=https://grpc.io/blog/grpc-load-balancing/>gRPC 负载平衡。</a></p><h2 id=grpc负载平衡相关的挑战>gRPC负载平衡相关的挑战</h2><p>gRPC 适用于 HTTP/2。 HHTP/2 上的 TCP 连接是长期存在的。 单个连接可以多路复用多个请求。 这减少了与连接管理相关的开销。 但这也意味着连接级负载均衡不是很有用。 Kubernetes 中的默认负载均衡基于连接级负载均衡。 因此，Kubernetes 默认负载平衡不适用于 gRPC。</p><p>为了证实这个假设，让我们创建一个 Kubernetes 应用程序。 此应用程序包括:</p><ul><li>服务器pod：Kubernetes部署，带有三个gRPC服务器pod。</li><li>客户端pod：Kubernetes部署，带有一个gRPC客户端pod。</li><li>Service：一个 ClusterIP服务，它选择所有服务器pod。</li></ul><p><img src=/images/grpc_kubernetes_deployment.png alt=image></p><h3 id=创建服务端-deployment>创建服务端 Deployment</h3><p>将以下代码保存为deployment-server.yaml</p><pre><code>cat &lt;&lt;EOF | kubectl apply -f - 
apiVersion: apps/v1
kind: Deployment
metadata:
  name: grpc-server
  labels:
    app: grpc-server
spec:
  replicas: 3
  selector:
    matchLabels:
      app: grpc-server
  template:
    metadata:
      labels:
        app: grpc-server
    spec:
      containers:
        - name: grpc-server
          image: techdozo/grpc-lb-server:1.0.0
EOF
</code></pre><p>以上Deployment创建了一个包含三个副本gRPC服务，服务端口为8001</p><p>检查pod是否创建成功</p><pre><code>$ kubectl get pods

NAME                           READY   STATUS    RESTARTS   AGE
grpc-server-6c9cd849-5pdbr     1/1     Running   0          1m
grpc-server-6c9cd849-86z7m     1/1     Running   0          1m
grpc-server-6c9cd849-mw9sb     1/1     Running   0          1m
</code></pre><h3 id=创建-service>创建 Service</h3><pre><code>cat &lt;&lt;EOF | kubectl apply -f -

apiVersion: v1
kind: Service
metadata:
  name: grpc-server-service
spec:
  type: ClusterIP
  selector:
    app: grpc-server
  ports:
    - port: 80
      targetPort: 8001
</code></pre><p><code>ClusterIP</code> 类型Service提供一个负载均衡的IP地址，它在通过标签选择器匹配的pod端点之间负载平衡流量</p><pre><code>Name:              grpc-server-service
Namespace:         default      
Selector:          app=grpc-server
Type:              ClusterIP
IP Family Policy:  SingleStack
IP Families:       IPv4
IP:                10.96.28.234
IPs:               10.96.28.234
Port:              &lt;unset&gt;  80/TCP
TargetPort:        8001/TCP
Endpoints:         10.244.0.11:8001,10.244.0.12:8001,10.244.0.13:8001
Session Affinity:  None
</code></pre><p>如上所示，Pod的IP地址是10.244.0.11:8001,10.244.0.12:8001,10.244.0.13:8001。 如果客户端在端口 80 上调用服务，那么它将跨端点（Pod的IP地址）对调用进行负载平衡。 但这对于 gRPC 来说并非如此。</p><h3 id=创建客户端deployment>创建客户端Deployment</h3><pre><code>cat &lt;&lt;EOF | kubectl apply -f -

apiVersion: apps/v1
kind: Deployment
metadata:
  name: grpc-client
  labels:
    app: grpc-client
spec:
  replicas: 1
  selector:
    matchLabels:
      app: grpc-client
  template:
    metadata:
      labels:
        app: grpc-client
    spec:
      containers:
        - name: grpc-client
          image: techdozo/grpc-lb-client:1.0.0
          env:
            - name: SERVER_HOST
              value: grpc-server-service:80
</code></pre><p>gRPC 客户端应用程序在启动时使用一个通道在 10 个并发线程中对服务器进行 1,000,000 次调用。 SERVER_HOST 环境变量指向服务 grpc-server-service 的 DNS。 在 gRPC 客户端上，通过将 SERVER_HOST ( serverHost) 传递为：</p><pre><code>ManagedChannelBuilder.forTarget(serverHost) .defaultLoadBalancingPolicy(&quot;round_robin&quot;) .usePlaintext() .build();
</code></pre><p>如果你检查服务器日志，会注意到所有客户端调用仅由一个服务器pod提供服务。</p><h3 id=使用headless-service的客户端负载平衡>使用Headless Service的客户端负载平衡</h3><p>可以使用Kubernetes Headless Service进行客户端循环负载平衡。 这种简单的负载平衡与gRPC一起开箱即用。 缺点是它没有考虑到服务器上的负载。</p><h3 id=什么是-headless-service>什么是 Headless Service?</h3><blockquote><p>幸运的是，Kubernetes 允许客户端通过 DNS 查找来发现 pod IP。通常，当您对服务执行 DNS 查找时，DNS 服务器会返回一个 IP — 服务的集群 IP。但是，如果您告诉 Kubernetes 您的服务不需要集群 IP（您可以通过在服务规范中将 clusterIP 字段设置为 None 来实现），DNS 服务器将返回 pod IP 而不是单个服务 IP。 DNS 服务器将返回服务的多个 A 记录，而不是返回单个 DNS A 记录，每个记录都指向当时支持该服务的单个 Pod 的 IP。因此，客户端可以进行简单的 DNS A 记录查找并获取属于服务的所有 pod 的 IP。然后客户端可以使用该信息连接到其中一个、多个或全部。
将服务规范中的 clusterIP 字段设置为 None 会使服务无头，因为 Kubernetes 不会为其分配集群 IP，客户端可以通过该 IP 连接到支持它的 pod。</p><pre><code>                                  &lt;&lt;Kubernetes in Action&gt;&gt; — Marko Lukša
</code></pre></blockquote><p>如下定义一个headless service：</p><pre><code>apiVersion: v1
kind: Service
metadata:
  name: grpc-server-service
spec:
  clusterIP: None
  selector:
    app: grpc-server
  ports:
    - port: 80
      targetPort: 8001
</code></pre><p>要使Service成为Headless Service，需要更改的唯一字段是将 .spec.clusterIP 字段设置为 None。</p><h3 id=验证dns>验证DNS</h3><p>要确认Headless Service的 DNS，请创建一个image为tutum/dnsutils的pod：</p><pre><code>kubectl run dnsutils --image=tutum/dnsutils --command --sleep infinity
</code></pre><p>然后运行命令</p><pre><code>kubectl exec dnsutils -- nslookup grpc-server-service
</code></pre><p>返回Headless service的FQDN如下：</p><pre><code>
Server:         10.96.0.10
Address:        10.96.0.10#53
Name:   grpc-server-service.default.svc.cluster.local
Address: 10.244.0.22
Name:   grpc-server-service.default.svc.cluster.local
Address: 10.244.0.20
Name:   grpc-server-service.default.svc.cluster.local
Address: 10.244.0.21
</code></pre><p>如您所见，Headless service解析为所有通过服务连接的Pod的IP地址。 将此与非无头服务返回的输出进行对比。</p><pre><code>Server: 10.96.0.10 Address: 10.96.0.10#53 Name: grpc-server-service.default.svc.cluster.local Address: 10.96.158.232
</code></pre><h3 id=配置客户端>配置客户端</h3><p>客户端应用程序剩下的唯一变化是指向带有服务器Pod端口的Headless Service，如下所示：</p><pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: grpc-client
  labels:
    app: grpc-client
spec:
  replicas: 1
  selector:
    matchLabels:
      app: grpc-client
  template:
    metadata:
      labels:
        app: grpc-client
    spec:
      containers:
        - name: grpc-client
          image: techdozo/grpc-lb-client:1.0.0
          env:
            - name: SERVER_HOST
              value: grpc-server-service:8001
</code></pre><blockquote><p>注意： SERVER_HOST 现在指向Headless Service grpc-server-service和端口8001.</p></blockquote><p>你也可以配置SERVER_HOST为FQDN如：</p><pre><code>name: SERVER_HOST 
value: &quot;grpc-server-service.default.svc.cluster.local:8001&quot;
</code></pre><p>重新部署client端的Deployment</p><pre><code>kubectl delete deployment.apps/grpc-client
kubectl apply -f deployment-client.yaml
</code></pre><p>可以看到服务的所有Pod打印了日志。</p><h2 id=总结>总结</h2><p>gRPC中有两种可用的负载平衡选项，代理和客户端。 由于gRPC连接是长期存在的，Kubernetes 的默认连接级负载平衡不适用于gRPC。 Kubernetes Headless Service是一种可以实现负载均衡的机制， Headless Service的DNS被解析为Pod的IP。</p><p>原文链接：https://pankaj02.medium.com/grpc-load-balancing-on-kubernetes-using-headless-service-13bce0423785</p></article></section><article class="ui segment utterances-comments" data-html2canvas-ignore><script src=https://utteranc.es/client.js repo=lixianwa/comments-for-myblog issue-term=og:title theme=github-light crossorigin=anonymous async></script></article></div></div><footer class="ui basic center aligned segment" style=background-color:initial><p>© 2014 - 2021 Lionel's Blog</p><p>Powered by <a href=https://gohugo.io/ target=_blank>Hugo</a> with theme <a href=https://github.com/g1eny0ung/hugo-theme-dream target=_blank>Dream</a>.</p></footer></div></section><section class=back><div class=dream-max-width><header class="ui basic very padded segment dream-header"><div class="ui small circular image"><img src=/me/avatar.jpeg alt=avatar></div><div class=content><h1 class="ui medium header">归零的小窝<div class="sub header">收集、总结、分享</div></h1><article class="ui horizontal list"><a class=item href=/posts><i class="archive icon" title=归档></i></a><a class=item href=/categories><i class="th list icon" title=所有分类></i></a><a class=item href=/tags><i class="tags icon" title=所有标签></i></a></article><article class=dream-tags><a class="ui label" href=/tags/archlinux/ title=archlinux>archlinux</a>
<a class="ui label" href=/tags/arthas/ title=arthas>arthas</a>
<a class="ui label" href=/tags/bug/ title=bug>bug</a>
<a class="ui label" href=/tags/c%E8%AF%AD%E8%A8%80/ title=c语言>c语言</a>
<a class="ui label" href=/tags/dapr/ title=Dapr>Dapr</a>
<a class="ui label" href=/tags/debug/ title=debug>debug</a>
<a class="ui label" href=/tags/dlv/ title=dlv>dlv</a>
<a class="ui label" href=/tags/go/ title=Go>Go</a>
<a class="ui label" href=/tags/grpc/ title=gRPC>gRPC</a>
<a class="ui label" href=/tags/headless-service/ title="Headless service">Headless service</a>
<a class="ui label" href=/tags/hexo/ title=Hexo>Hexo</a>
<a class="ui label" href=/tags/ios/ title=iOS>iOS</a>
<a class="ui label" href=/tags/java/ title=java>java</a>
<a class="ui label" href=/tags/jekyll/ title=jekyll>jekyll</a>
<a class="ui label" href=/tags/jupyter-notebook/ title="Jupyter notebook">Jupyter notebook</a>
<a class="ui label" href=/tags/kubernetes/ title=Kubernetes>Kubernetes</a>
<a class="ui label" href=/tags/markdown/ title=markdown>markdown</a>
<a class="ui label" href=/tags/mongodb/ title=mongodb>mongodb</a>
<a class="ui label" href=/tags/nginx/ title=nginx>nginx</a>
<a class="ui label" href=/tags/pandas/ title=Pandas>Pandas</a>
<a class="ui label" href=/tags/reactivecocoa/ title=ReactiveCocoa>ReactiveCocoa</a>
<a class="ui label" href=/tags/redis/ title=redis>redis</a>
<a class="ui label" href=/tags/restful-api/ title="RESTFul API">RESTFul API</a>
<a class="ui label" href=/tags/swift/ title=Swift>Swift</a>
<a class="ui label" href=/tags/v2ray/ title=v2ray>v2ray</a>
<a class="ui label" href=/tags/xcode/ title=Xcode>Xcode</a>
<a class="ui label" href=/tags/%E5%86%85%E5%AD%98/ title=内存>内存</a>
<a class="ui label" href=/tags/%E5%8D%9A%E5%AE%A2/ title=博客>博客</a>
<a class="ui label" href=/tags/%E5%B7%A5%E5%85%B7/ title=工具>工具</a>
<a class="ui label" href=/tags/%E5%BC%80%E6%BA%90/ title=开源>开源</a>
<a class="ui label" href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/ title=微服务>微服务</a>
<a class="ui label" href=/tags/%E6%8F%90%E9%97%AE/ title=提问>提问</a>
<a class="ui label" href=/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ title=数据分析>数据分析</a>
<a class="ui label" href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/ title=数据库>数据库</a>
<a class="ui label" href=/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ title=“机器学习”>“机器学习”</a>
<a class="ui label" href=/tags/%E6%AD%BB%E6%9C%BA/ title=死机>死机</a>
<a class="ui label" href=/tags/%E6%B3%9B%E5%9E%8B/ title=泛型>泛型</a>
<a class="ui label" href=/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/ title=“深度学习”>“深度学习”</a>
<a class="ui label" href=/tags/%E6%B8%B8%E8%AE%B0/ title=游记>游记</a>
<a class="ui label" href=/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/ title=科学上网>科学上网</a>
<a class="ui label" href=/tags/%E7%AE%97%E5%AD%90/ title=算子>算子</a>
<a class="ui label" href=/tags/%E7%BF%BB%E8%AF%91/ title=翻译>翻译</a>
<a class="ui label" href=/tags/%E8%87%AA%E8%A1%8C%E8%BD%A6/ title=自行车>自行车</a>
<a class="ui label" href=/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ title=读书笔记>读书笔记</a></article></div></header><div class="ui relaxed grid dream-grid dream-back"><div class="sixteen wide mobile eight wide tablet four wide computer column dream-column"><article class="ui segment markdown-body"><div class="ui medium header">关于</div><p>要么忙着生活，要么赶着去死!</p></article></div><div class="sixteen wide mobile eight wide tablet four wide computer column dream-column"><article class="ui segment"><div class="ui medium header">社交链接</div><nav class="ui secondary menu dream-menu dream-socials"><div class=item><a href=/index.xml><i class="large rss square icon" title=RSS></i></a></div><div class=item><a href=mailto:lixianwa@gmail.com><i class="large mail icon" title=Email></i></a></div></nav></article></div><div class="sixteen wide mobile eight wide tablet four wide computer column dream-column"><article class="ui segment"><a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/><img alt=知识共享许可协议 style=border-width:0 src=https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png></a><br>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</article></div></div></div></section></div></div><script>window.defaultDark=null,window.backgroundDark="black",window.backgroundImageDark=null,window.darkNav=null,window.hasTwitterEmbed=null,window.hasTwitterEmbed&&(window.twttr=function(c,d,e){var b,f=c.getElementsByTagName(d)[0],a=window.twttr||{};return c.getElementById(e)?a:(b=c.createElement(d),b.id=e,b.src='https://platform.twitter.com/widgets.js',f.parentNode.insertBefore(b,f),a._e=[],a.ready=function(b){a._e.push(b)},a)}(document,'script','twitter-wjs'))</script><script src=/js/jquery.min.js></script><script src=/js/semantic.min.js></script><script src=/js/jquery.overlayScrollbars.min.js></script><script src=/js/header.js></script><script src=/js/main.js></script><script src=/js/theme.js></script><script src=/js/html2canvas.min.js></script><script src=/js/post.js></script><script src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js></script><script src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/ocaml.min.js></script><script>hljs.initHighlightingOnLoad(),setHighlightTheme();function setHighlightTheme(){var a=localStore.getItem('hugo-theme-dream-is-dark'),b,c,d;a=a?a:window.defaultDark?'y':a,b="gruvbox-light",c="gruvbox-dark",d=a==='y'?c:b,$('link[data-highlight]').attr('href','https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/'+d+'.min.css'),$('pre').css('background',a==='y'?'#333':'')}</script><div class="ui inverted segment" id=dream-search><div class="ui search"><div class="ui transparent input"><input class=prompt type=text placeholder=搜索></div><div class=results></div></div></div><script>$(document).ready(function(){$.getJSON('https://lixianwa.github.io//index.json',function(a){$('.ui.search').search({source:a,searchFields:['title'],showNoResults:!0})})})</script><script src=/js/search.js></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','172168556','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>