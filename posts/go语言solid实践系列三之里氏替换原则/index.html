<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><title>Go语言SOLID实践系列三之里氏替换原则 | Lionel's Blog</title><link href=/favicon.ico rel="shortcut icon" type=image/x-icon><meta name=author content="归零"><meta name=description content="引用wikipedia上对里氏替换原则的解释：
 里氏替换原则（Liskov Substitution principle）是对子类型的特别定义, 指“派生类（子类）对象可以在程序中代替其基类（超类）对象”。
"><meta name=generator content="Hugo 0.81.0"><link rel=canonical href=https://lixianwa.github.io/posts/go%E8%AF%AD%E8%A8%80solid%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97%E4%B8%89%E4%B9%8B%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/><meta property="og:title" content="Go语言SOLID实践系列三之里氏替换原则"><meta property="og:description" content="引用wikipedia上对里氏替换原则的解释：

里氏替换原则（Liskov Substitution principle）是对子类型的特别定义, 指“派生类（子类）对象可以在程序中代替其基类（超类）对象”。
"><meta property="og:type" content="article"><meta property="og:url" content="https://lixianwa.github.io/posts/go%E8%AF%AD%E8%A8%80solid%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97%E4%B8%89%E4%B9%8B%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-10T22:30:13+08:00"><meta property="article:modified_time" content="2022-01-10T22:30:13+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go语言SOLID实践系列三之里氏替换原则"><meta name=twitter:description content="引用wikipedia上对里氏替换原则的解释：

里氏替换原则（Liskov Substitution principle）是对子类型的特别定义, 指“派生类（子类）对象可以在程序中代替其基类（超类）对象”。
"><link rel=stylesheet href=/css/semantic.min.css><link rel=stylesheet href=/css/icomoon.css><link rel=stylesheet href=/css/OverlayScrollbars.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/site.css><style>a:not(.ui.button):hover{text-decoration:underline}a:not(.ui.button){color:#2e8b57!important}.inverted a:not(.ui.button),.inverted a:not(.ui.button):hover{color:#8fbc8f!important}body.default{background-color:#f7f7f7;background-image:url(/me/background.jpeg)}body.dark{background-color:#000}</style><link rel=stylesheet data-highlight href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/gruvbox-light.min.css><link rel=stylesheet href=/css/custom.css></head><body class=default><nav class="ui secondary menu dream-menu"><div class=item><i class="large link bullseye icon dream-flip-toggle" title=翻转！></i></div><div class=item><i class="large link home icon" title=首页 onclick="window.location.href='https://lixianwa.github.io/'"></i></div><div class=item><i class="large link icon theme-switch" onclick=themeSwitch()></i></div><div class=item><i class="large link search icon" onclick=toggleSearch()></i></div></nav><div class=flip-container><div class=flipper><section class=front><div class=dream-max-width><div class="ui relaxed grid dream-grid dream-grid-single"><aside class="sixteen wide mobile sixteen wide tablet four wide computer column dream-single-aside"><div class="ui segment toc"><nav id=TableOfContents><ul><li><a href=#不遵守里氏替换原则>不遵守里氏替换原则</a></li><li><a href=#如何遵守里氏替换原则>如何遵守里氏替换原则</a></li><li><a href=#总结>总结</a></li></ul></nav></div><div class="ui segment actions"><button class="ui circular icon button save-as-image" title=保存为图片 onclick=savePostAsImg()>
<i class="save icon"></i></button>
<a href="https://twitter.com/intent/tweet?text=Go%e8%af%ad%e8%a8%80SOLID%e5%ae%9e%e8%b7%b5%e7%b3%bb%e5%88%97%e4%b8%89%e4%b9%8b%e9%87%8c%e6%b0%8f%e6%9b%bf%e6%8d%a2%e5%8e%9f%e5%88%99&url=https%3a%2f%2flixianwa.github.io%2fposts%2fgo%25E8%25AF%25AD%25E8%25A8%2580solid%25E5%25AE%259E%25E8%25B7%25B5%25E7%25B3%25BB%25E5%2588%2597%25E4%25B8%2589%25E4%25B9%258B%25E9%2587%258C%25E6%25B0%258F%25E6%259B%25BF%25E6%258D%25A2%25E5%258E%259F%25E5%2588%2599%2f" class="ui circular twitter icon button"><i class="twitter icon"></i></a><a href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flixianwa.github.io%2fposts%2fgo%25E8%25AF%25AD%25E8%25A8%2580solid%25E5%25AE%259E%25E8%25B7%25B5%25E7%25B3%25BB%25E5%2588%2597%25E4%25B8%2589%25E4%25B9%258B%25E9%2587%258C%25E6%25B0%258F%25E6%259B%25BF%25E6%258D%25A2%25E5%258E%259F%25E5%2588%2599%2f" class="ui circular facebook icon button"><i class="facebook icon"></i></a></div></aside><div class="sixteen wide mobile sixteen wide tablet twelve wide computer column markdown-body dream-single" id=dream-save-post-as-img><section class="ui attached segment"><header><h1 class="ui large header">Go语言SOLID实践系列三之里氏替换原则<div class="sub header">@
归零
|
星期一，一月 10 日，2022 年
| 4 分钟阅读
| 更新于
星期一，一月 10 日，2022 年</div></h1></header><article class=main><p>引用wikipedia上对<a href=https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99>里氏替换原则</a>的解释：</p><blockquote><p>里氏替换原则（Liskov Substitution principle）是对子类型的特别定义, 指“派生类（子类）对象可以在程序中代替其基类（超类）对象”。</p></blockquote><h2 id=不遵守里氏替换原则>不遵守里氏替换原则</h2><p>我们第一次听说这个原理是在1988年，由芭芭拉·里斯克（Barbara Liskov）创作。后来，Bob大叔在他的论文中对这个话题发表了自己的看法，后来又将其作为SOLID原则之一。让我们看看它说了什么：</p><blockquote><p>Let Φ(x) be a property provable about objects x of type T. Then Φ(y) should be true for objects y of type S where S is a subtype of T.</p></blockquote><p>说实话这是一个什么样的定义？在写这篇文章的时候，即使从根本上理解了LSP，我仍然无法抓住这个定义。让我们再试一次：</p><blockquote><p>If S is a subtype of T, then objects of type T in a program may be replaced with objects of type S without altering any of the desirable properties of that program.</p></blockquote><p>翻译：</p><blockquote><p>如果 S 是 T 的子类型，则程序中 T 类型的对象可以替换为 S 类型的对象，而不会更改该程序的任何所需属性。</p></blockquote><p>也就是说，如果 ObjectA 是 ClassA 的实例，而 ObjectB 是 ClassB 的实例，而 ClassB 是 ClassA 的子类型— 如果我们在代码中的某个位置使用 ObjectB 而不是 ObjectA，则应用程序的功能不得中断。</p><p>我们在这里讨论类和继承，这是我们在Go中不认识的两种范式。尽管如此，我们仍然可以通过使用接口和多态性来应用这一原则。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>User</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>ID</span> <span style=color:#a6e22e>uuid</span>.<span style=color:#a6e22e>UUID</span>
	<span style=color:#75715e>//
</span><span style=color:#75715e></span>	<span style=color:#75715e>// some fields
</span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>UserRepository</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>Update</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>user</span> <span style=color:#a6e22e>User</span>) <span style=color:#66d9ef>error</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>DBUserRepository</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>db</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gorm</span>.<span style=color:#a6e22e>DB</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>DBUserRepository</span>) <span style=color:#a6e22e>Update</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>user</span> <span style=color:#a6e22e>User</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>WithContext</span>(<span style=color:#a6e22e>ctx</span>).<span style=color:#a6e22e>Delete</span>(<span style=color:#a6e22e>user</span>).<span style=color:#a6e22e>Error</span>
}
</code></pre></div><p>以上代码示例，我几乎找不到比这个更糟糕，更愚蠢的了。例如，它不是像 Update 方法所说的那样更新数据库中的用户，而是将其删除。</p><p>但是，接口 UserRepository 之后，我们有一个结构体 DBUserRepository。尽管此结构实现了初始接口，但它没有执行接口声明它应该执行的操作。</p><p>它破坏了接口的功能，而不是遵循。以下是 LSP 在 Go 中的观点：结构体不得违反接口的用途。如下示例：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>UserRepository</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>Create</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>user</span> <span style=color:#a6e22e>User</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>User</span>, <span style=color:#66d9ef>error</span>)
	<span style=color:#a6e22e>Update</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>user</span> <span style=color:#a6e22e>User</span>) <span style=color:#66d9ef>error</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>DBUserRepository</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>db</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gorm</span>.<span style=color:#a6e22e>DB</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>DBUserRepository</span>) <span style=color:#a6e22e>Create</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>user</span> <span style=color:#a6e22e>User</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>User</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>WithContext</span>(<span style=color:#a6e22e>ctx</span>).<span style=color:#a6e22e>Create</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>user</span>).<span style=color:#a6e22e>Error</span>
	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>user</span>, <span style=color:#a6e22e>err</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>DBUserRepository</span>) <span style=color:#a6e22e>Update</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>user</span> <span style=color:#a6e22e>User</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>WithContext</span>(<span style=color:#a6e22e>ctx</span>).<span style=color:#a6e22e>Save</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>user</span>).<span style=color:#a6e22e>Error</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>MemoryUserRepository</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>users</span> <span style=color:#66d9ef>map</span>[<span style=color:#a6e22e>uuid</span>.<span style=color:#a6e22e>UUID</span>]<span style=color:#a6e22e>User</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MemoryUserRepository</span>) <span style=color:#a6e22e>Create</span>(<span style=color:#a6e22e>_</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>user</span> <span style=color:#a6e22e>User</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>User</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>users</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>users</span> = <span style=color:#66d9ef>map</span>[<span style=color:#a6e22e>uuid</span>.<span style=color:#a6e22e>UUID</span>]<span style=color:#a6e22e>User</span>{}
	}
	<span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>ID</span> = <span style=color:#a6e22e>uuid</span>.<span style=color:#a6e22e>New</span>()
	<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>users</span>[<span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>ID</span>] = <span style=color:#a6e22e>user</span>
	
	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>user</span>, <span style=color:#66d9ef>nil</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MemoryUserRepository</span>) <span style=color:#a6e22e>Update</span>(<span style=color:#a6e22e>_</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>user</span> <span style=color:#a6e22e>User</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>users</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>users</span> = <span style=color:#66d9ef>map</span>[<span style=color:#a6e22e>uuid</span>.<span style=color:#a6e22e>UUID</span>]<span style=color:#a6e22e>User</span>{}
	}
	<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>users</span>[<span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>ID</span>] = <span style=color:#a6e22e>user</span>

	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>在这里，我们有新的 UserRepository 接口及其两个实现：DBUserRepository 和 MemoryUserRepository。正如我们所看到的，MemoryUserRepository确实需要context参数，但它仍然存在以尊重接口。</p><p>问题从这里开始。我们调整了 MemoryUserRepository 来支持该接口，尽管这种意图是不自然的。因此，我们可以在应用程序中切换数据源，其中一个源不是永久存储。</p><p>存储库模式的目的是表示基础永久数据存储（如数据库）的接口。它不应该扮演缓存系统的角色，就像我们在这里将用户存储在内存中一样。
有时，不自然的实现会在编码本身中产生后果，而不仅仅是在语义上。这些情况更明显，难以实现，因为它们需要重大重构。</p><p>为了说明这种情况，我们可以检查有关几何形状的着名示例。这个例子的有趣之处在于，它与几何学中的事实相矛盾。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ConvexQuadrilateral</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>GetArea</span>() <span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Rectangle</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>ConvexQuadrilateral</span>
	<span style=color:#a6e22e>SetA</span>(<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>)
	<span style=color:#a6e22e>SetB</span>(<span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>)
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Oblong</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Rectangle</span>
	<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>
	<span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Oblong</span>) <span style=color:#a6e22e>SetA</span>(<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>a</span> = <span style=color:#a6e22e>a</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Oblong</span>) <span style=color:#a6e22e>SetB</span>(<span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>b</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#a6e22e>Oblong</span>) <span style=color:#a6e22e>GetArea</span>() <span style=color:#66d9ef>int</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>b</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Square</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Rectangle</span>
	<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Square</span>) <span style=color:#a6e22e>SetA</span>(<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>a</span> = <span style=color:#a6e22e>a</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#a6e22e>Square</span>) <span style=color:#a6e22e>GetArea</span>() <span style=color:#66d9ef>int</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>a</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Square</span>) <span style=color:#a6e22e>SetB</span>(<span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#75715e>//
</span><span style=color:#75715e></span>	<span style=color:#75715e>// should it be o.a = b ?
</span><span style=color:#75715e></span>	<span style=color:#75715e>// or should it be empty?
</span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span><span style=color:#75715e></span>}
</code></pre></div><p>在上面的示例中，我们可以看到Go中几何形状的实现。在几何学中，我们可以将凸四边形，矩形，长方形和正方形与子类型进行比较。</p><p>如果我们将其移动到Go代码中以实现面积计算的逻辑，我们最终可能会得到类似于我们上面看到的东西。在顶部，我们有一个接口凸四边形。
此接口仅定义一个方法，即 GetArea。作为凸四边形的子类型，我们可以定义一个接口矩形。此子类型有两个涉及其区域的边，因此我们必须提供 SetA 和 SetB。</p><p>接下来是实际实现。第一个是长方形，它可以有更宽或更宽的高度。在几何中，它是任何非正方形的矩形。实现此结构的逻辑很容易。</p><p>矩形的第二个子类型是正方形。在几何中，正方形是矩形的子类型，但是如果我们在软件开发中遵循这一点，我们只能在实现中制造问题。</p><p>正方形有四条相等的边。因此，这使得SetB过时了。为了尊重我们最初选择的子类型，我们意识到我们的代码具有过时的方法。同样的问题是，如果我们选择一条稍微不同的路径：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ConvexQuadrilateral</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>GetArea</span>() <span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>EquilateralRectangle</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>ConvexQuadrilateral</span>
	<span style=color:#a6e22e>SetA</span>(<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>)
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Oblong</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>EquilateralRectangle</span>
	<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>
	<span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Oblong</span>) <span style=color:#a6e22e>SetA</span>(<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>a</span> = <span style=color:#a6e22e>a</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Oblong</span>) <span style=color:#a6e22e>SetB</span>(<span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#75715e>// where is this method defined?
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>b</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#a6e22e>Oblong</span>) <span style=color:#a6e22e>GetArea</span>() <span style=color:#66d9ef>int</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>b</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Square</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>EquilateralRectangle</span>
	<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Square</span>) <span style=color:#a6e22e>SetA</span>(<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>a</span> = <span style=color:#a6e22e>a</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#a6e22e>Square</span>) <span style=color:#a6e22e>GetArea</span>() <span style=color:#66d9ef>int</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>a</span>
}
</code></pre></div><p>在上面的示例中，我们引入了 EquilateralRectangle 接口，而不是 Rectangle。在几何中，这应该是一个具有所有四个相等边的矩形。</p><p>在这种情况下，当我们的接口仅定义 SetA 方法时，我们在实现中避免了过时的代码。尽管如此，这还是打破了LSP，因为我们为Oblong引入了一种额外的方法SetB，没有这种方法，我们就无法计算面积，即使我们的接口说我们可以。</p><p>因此，我们已经开始在Go中捕捉里氏替换原则的想法。因此，我们可以总结一下，如果我们打破它，可能会出错：</p><ul><li>它为实现提供了一个错误的快捷方式。</li><li>它可能导致代码过时。</li><li>它可能会损坏预期的代码执行。</li><li>它可以打破所需的用例。</li><li>它可能导致无法维护的接口结构。</li><li>&mldr;</li></ul><h2 id=如何遵守里氏替换原则>如何遵守里氏替换原则</h2><p>我们只能通过尊重接口的用途和方法，在 Go 接口中提供子类型。</p><p>我将避免为我们的第一个示例添加正确的实现，因为它非常清楚 - Update方法应该更新User而不是删除它。</p><p>因此，让我们首先着手解决 UserRepository 接口的不同实现的问题：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>UserRepository</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>Create</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>user</span> <span style=color:#a6e22e>User</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>User</span>, <span style=color:#66d9ef>error</span>)
	<span style=color:#a6e22e>Update</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>user</span> <span style=color:#a6e22e>User</span>) <span style=color:#66d9ef>error</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>MySQLUserRepository</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>db</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gorm</span>.<span style=color:#a6e22e>DB</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CassandraUserRepository</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>session</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gocql</span>.<span style=color:#a6e22e>Session</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>UserCache</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>Create</span>(<span style=color:#a6e22e>user</span> <span style=color:#a6e22e>User</span>)
	<span style=color:#a6e22e>Update</span>(<span style=color:#a6e22e>user</span> <span style=color:#a6e22e>User</span>)
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>MemoryUserCache</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>users</span> <span style=color:#66d9ef>map</span>[<span style=color:#a6e22e>uuid</span>.<span style=color:#a6e22e>UUID</span>]<span style=color:#a6e22e>User</span>
}
</code></pre></div><p>在此示例中，我们将接口一分为二，具有明确的用途和不同方法的签名。现在，我们有了 UserRepository 接口和 UserCache 接口。</p><p>用户存储库的目的现在肯定是将用户数据永久存储到某个存储中。为此，我们准备了具体的实现，如MySQLUserRepository和CassandraUserRepository。</p><p>另一方面，我们有UserCache接口，清楚地知道我们需要它来暂时将用户数据保存在某些缓存中。作为具体实现，我们可以使用MemoryUserCache。
现在我们可以切换到几何示例，其中的情况有点复杂：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ConvexQuadrilateral</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>GetArea</span>() <span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>EquilateralQuadrilateral</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>ConvexQuadrilateral</span>
	<span style=color:#a6e22e>SetA</span>(<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>)
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>NonEquilateralQuadrilateral</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>ConvexQuadrilateral</span>
	<span style=color:#a6e22e>SetA</span>(<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>)
	<span style=color:#a6e22e>SetB</span>(<span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>)
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>NonEquiangularQuadrilateral</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>ConvexQuadrilateral</span>
	<span style=color:#a6e22e>SetAngle</span>(<span style=color:#a6e22e>angle</span> <span style=color:#66d9ef>float64</span>)
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Oblong</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>NonEquilateralQuadrilateral</span>
	<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>
	<span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Square</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>EquilateralQuadrilateral</span>
	<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Parallelogram</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>NonEquilateralQuadrilateral</span>
	<span style=color:#a6e22e>NonEquiangularQuadrilateral</span>
	<span style=color:#a6e22e>a</span>     <span style=color:#66d9ef>int</span>
	<span style=color:#a6e22e>b</span>     <span style=color:#66d9ef>int</span>
	<span style=color:#a6e22e>angle</span> <span style=color:#66d9ef>float64</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Rhombus</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>EquilateralQuadrilateral</span>
	<span style=color:#a6e22e>NonEquiangularQuadrilateral</span>
	<span style=color:#a6e22e>a</span>     <span style=color:#66d9ef>int</span>
	<span style=color:#a6e22e>angle</span> <span style=color:#66d9ef>float64</span>
}
</code></pre></div><p>为了支持Go中几何形状的子类型，我们应该考虑它们的所有特征，以避免损坏或过时的方法。</p><p>在本例中，我们引入了三个新接口：EquilateralQuadrilateral（具有所有四个相等边的四边形）、NonEquilateralQuadrilateral（具有两对相等边的四边形）和NonEquiangularQuadrilateral（具有两对相等角的四边形）。</p><p>这些接口中的每一个都提供了提供面积计算所需数据所需的其他方法。</p><p>现在，我们可以定义一个正方形，仅使用 SetA 方法，长方形同时包含 SetA 和 SetB，并行四边形包含所有这些方法和 SetAngle。因此，我们在这里没有使用子类型，而更像是功能。
通过这两个固定的示例，我们重构了代码，以便它始终可以满足最终用户的期望。它还会删除过时的方法，并且不会破坏其中任何方法。代码现在稳定。</p><h2 id=总结>总结</h2><p>里氏替换原理告诉我们什么是正确的替代方法。我们永远不应该做强制多态性，即使它反映了现实世界的情况。</p><p>LSP 代表单词 SOLID 中的字母 L。尽管它绑定到 Go 中不支持的继承和类，但我们仍然可以将此原则用于多态性和接口。</p><p>参考：</p><p>1、https://levelup.gitconnected.com/practical-solid-in-golang-liskov-substitution-principle-e0d2eb9dd39</p><p>2、https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99</p></article></section><article class="ui segment utterances-comments" data-html2canvas-ignore><script src=https://utteranc.es/client.js repo=lixianwa/comments-for-myblog issue-term=og:title theme=github-light crossorigin=anonymous async></script></article></div></div><footer class="ui basic center aligned segment" style=background-color:initial><p>© 2014 - 2022 Lionel's Blog</p><p>Powered by <a href=https://gohugo.io/ target=_blank>Hugo</a> with theme <a href=https://github.com/g1eny0ung/hugo-theme-dream target=_blank>Dream</a>.</p></footer></div></section><section class=back><div class=dream-max-width><header class="ui basic very padded segment dream-header"><div class="ui small circular image"><img src=/me/avatar.jpeg alt=avatar></div><div class=content><h1 class="ui medium header">归零的小窝<div class="sub header">收集、总结、分享</div></h1><article class="ui horizontal list"><a class=item href=/posts><i class="archive icon" title=归档></i></a><a class=item href=/categories><i class="th list icon" title=所有分类></i></a><a class=item href=/tags><i class="tags icon" title=所有标签></i></a></article><article class=dream-tags><a class="ui label" href=/tags/actor/ title=Actor>Actor</a>
<a class="ui label" href=/tags/archlinux/ title=archlinux>archlinux</a>
<a class="ui label" href=/tags/arthas/ title=arthas>arthas</a>
<a class="ui label" href=/tags/bug/ title=bug>bug</a>
<a class="ui label" href=/tags/c%E8%AF%AD%E8%A8%80/ title=c语言>c语言</a>
<a class="ui label" href=/tags/dapr/ title=Dapr>Dapr</a>
<a class="ui label" href=/tags/debug/ title=debug>debug</a>
<a class="ui label" href=/tags/dlv/ title=dlv>dlv</a>
<a class="ui label" href=/tags/docker/ title=Docker>Docker</a>
<a class="ui label" href=/tags/go/ title=Go>Go</a>
<a class="ui label" href=/tags/grpc/ title=gRPC>gRPC</a>
<a class="ui label" href=/tags/headless-service/ title="Headless service">Headless service</a>
<a class="ui label" href=/tags/hexo/ title=Hexo>Hexo</a>
<a class="ui label" href=/tags/ios/ title=iOS>iOS</a>
<a class="ui label" href=/tags/istio/ title=Istio>Istio</a>
<a class="ui label" href=/tags/java/ title=java>java</a>
<a class="ui label" href=/tags/jekyll/ title=jekyll>jekyll</a>
<a class="ui label" href=/tags/jupyter-notebook/ title="Jupyter notebook">Jupyter notebook</a>
<a class="ui label" href=/tags/kubernetes/ title=Kubernetes>Kubernetes</a>
<a class="ui label" href=/tags/letsencrypt/ title=Letsencrypt>Letsencrypt</a>
<a class="ui label" href=/tags/markdown/ title=markdown>markdown</a>
<a class="ui label" href=/tags/mongodb/ title=mongodb>mongodb</a>
<a class="ui label" href=/tags/nginx/ title=nginx>nginx</a>
<a class="ui label" href=/tags/pandas/ title=Pandas>Pandas</a>
<a class="ui label" href=/tags/reactivecocoa/ title=ReactiveCocoa>ReactiveCocoa</a>
<a class="ui label" href=/tags/redis/ title=redis>redis</a>
<a class="ui label" href=/tags/restful-api/ title="RESTFul API">RESTFul API</a>
<a class="ui label" href=/tags/solid/ title=SOLID>SOLID</a>
<a class="ui label" href=/tags/ssl%E8%AF%81%E4%B9%A6/ title=SSL证书>SSL证书</a>
<a class="ui label" href=/tags/swift/ title=Swift>Swift</a>
<a class="ui label" href=/tags/v2ray/ title=v2ray>v2ray</a>
<a class="ui label" href=/tags/xcode/ title=Xcode>Xcode</a>
<a class="ui label" href=/tags/%E5%86%85%E5%AD%98/ title=内存>内存</a>
<a class="ui label" href=/tags/%E5%8D%9A%E5%AE%A2/ title=博客>博客</a>
<a class="ui label" href=/tags/%E5%B7%A5%E5%85%B7/ title=工具>工具</a>
<a class="ui label" href=/tags/%E5%BC%80%E6%BA%90/ title=开源>开源</a>
<a class="ui label" href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/ title=微服务>微服务</a>
<a class="ui label" href=/tags/%E6%8F%90%E9%97%AE/ title=提问>提问</a>
<a class="ui label" href=/tags/%E6%95%99%E7%A8%8B/ title=教程>教程</a>
<a class="ui label" href=/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ title=数据分析>数据分析</a>
<a class="ui label" href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/ title=数据库>数据库</a>
<a class="ui label" href=/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/ title=最佳实践>最佳实践</a>
<a class="ui label" href=/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ title=“机器学习”>“机器学习”</a>
<a class="ui label" href=/tags/%E6%AD%BB%E6%9C%BA/ title=死机>死机</a>
<a class="ui label" href=/tags/%E6%B3%9B%E5%9E%8B/ title=泛型>泛型</a>
<a class="ui label" href=/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/ title=“深度学习”>“深度学习”</a>
<a class="ui label" href=/tags/%E6%B8%B8%E8%AE%B0/ title=游记>游记</a>
<a class="ui label" href=/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/ title=科学上网>科学上网</a>
<a class="ui label" href=/tags/%E7%AE%97%E5%AD%90/ title=算子>算子</a>
<a class="ui label" href=/tags/%E7%BF%BB%E8%AF%91/ title=翻译>翻译</a>
<a class="ui label" href=/tags/%E8%87%AA%E8%A1%8C%E8%BD%A6/ title=自行车>自行车</a>
<a class="ui label" href=/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ title=读书笔记>读书笔记</a></article></div></header><div class="ui relaxed grid dream-grid dream-back"><div class="sixteen wide mobile eight wide tablet four wide computer column dream-column"><article class="ui segment markdown-body"><div class="ui medium header">关于</div><p>要么忙着生活，要么赶着去死!</p></article></div><div class="sixteen wide mobile eight wide tablet four wide computer column dream-column"><article class="ui segment"><div class="ui medium header">社交链接</div><nav class="ui secondary menu dream-menu dream-socials"><div class=item><a href=/index.xml><i class="large rss square icon" title=RSS></i></a></div><div class=item><a href=mailto:lixianwa@gmail.com><i class="large mail icon" title=Email></i></a></div></nav></article></div><div class="sixteen wide mobile eight wide tablet four wide computer column dream-column"><article class="ui segment"><a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/><img alt=知识共享许可协议 style=border-width:0 src=https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png></a><br>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</article></div></div></div></section></div></div><script>window.defaultDark=null,window.backgroundDark="black",window.backgroundImageDark=null,window.darkNav=null,window.hasTwitterEmbed=null,window.hasTwitterEmbed&&(window.twttr=function(c,d,e){var b,f=c.getElementsByTagName(d)[0],a=window.twttr||{};return c.getElementById(e)?a:(b=c.createElement(d),b.id=e,b.src='https://platform.twitter.com/widgets.js',f.parentNode.insertBefore(b,f),a._e=[],a.ready=function(b){a._e.push(b)},a)}(document,'script','twitter-wjs'))</script><script src=/js/jquery.min.js></script><script src=/js/semantic.min.js></script><script src=/js/jquery.overlayScrollbars.min.js></script><script src=/js/header.js></script><script src=/js/main.js></script><script src=/js/theme.js></script><script src=/js/html2canvas.min.js></script><script src=/js/post.js></script><script src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js></script><script src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/ocaml.min.js></script><script>hljs.initHighlightingOnLoad(),setHighlightTheme();function setHighlightTheme(){var a=localStore.getItem('hugo-theme-dream-is-dark'),b,c,d;a=a?a:window.defaultDark?'y':a,b="gruvbox-light",c="gruvbox-dark",d=a==='y'?c:b,$('link[data-highlight]').attr('href','https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/'+d+'.min.css'),$('pre').css('background',a==='y'?'#333':'')}</script><div class="ui inverted segment" id=dream-search><div class="ui search"><div class="ui transparent input"><input class=prompt type=text placeholder=搜索></div><div class=results></div></div></div><script>$(document).ready(function(){$.getJSON('https://lixianwa.github.io//index.json',function(a){$('.ui.search').search({source:a,searchFields:['title'],showNoResults:!0})})})</script><script src=/js/search.js></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','172168556','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>