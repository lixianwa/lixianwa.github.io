<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><title>ReactiveCocoa中的基本算子 | Lionel's Blog</title><link href=/favicon.ico rel="shortcut icon" type=image/x-icon><meta name=author content="归零"><meta name=description content="原文链接: Basic Operators
这个文档解释ReactiveCocoa中最常用的Operator，以及一些用例。注意Operators，在这里指的是signal和signal producers之间的转换，不是Swift中的操作符，换句话说，这些是ReactiveCocoa提供处理事件流的组合原语。该文档使用术语“事件流”来描述Signal和SignalProducer的概念。
事件流副作用 观察（Observation） Signal可以被观察通过observe函数，需要一个Observer作为参数，任何事件流都会发送给它。
signal.observe(Signal.Observer { event in switch event { case let .Next(next): print(&amp;quot;Next: \(next)&amp;quot;) case let .Failed(error): print(&amp;quot;Failed: \(error)&amp;quot;) case .Completed: print(&amp;quot;Completed&amp;quot;) case .Interrupted: print(&amp;quot;Interrupted&amp;quot;) } }) "><meta name=generator content="Hugo 0.81.0"><link rel=canonical href=https://lixianwa.github.io/posts/basic-operators/><meta property="og:title" content="ReactiveCocoa中的基本算子"><meta property="og:description" content="原文链接: Basic Operators
这个文档解释ReactiveCocoa中最常用的Operator，以及一些用例。注意Operators，在这里指的是signal和signal producers之间的转换，不是Swift中的操作符，换句话说，这些是ReactiveCocoa提供处理事件流的组合原语。该文档使用术语“事件流”来描述Signal和SignalProducer的概念。
事件流副作用
观察（Observation）
Signal可以被观察通过observe函数，需要一个Observer作为参数，任何事件流都会发送给它。
signal.observe(Signal.Observer { event in
  switch event {
    case let .Next(next):
      print(&#34;Next: \(next)&#34;)
    case let .Failed(error):
      print(&#34;Failed: \(error)&#34;)
    case .Completed:
      print(&#34;Completed&#34;)
    case .Interrupted:
      print(&#34;Interrupted&#34;)
  }
})
"><meta property="og:type" content="article"><meta property="og:url" content="https://lixianwa.github.io/posts/basic-operators/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-08-14T00:00:00+00:00"><meta property="article:modified_time" content="2016-08-14T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="ReactiveCocoa中的基本算子"><meta name=twitter:description content="原文链接: Basic Operators
这个文档解释ReactiveCocoa中最常用的Operator，以及一些用例。注意Operators，在这里指的是signal和signal producers之间的转换，不是Swift中的操作符，换句话说，这些是ReactiveCocoa提供处理事件流的组合原语。该文档使用术语“事件流”来描述Signal和SignalProducer的概念。
事件流副作用
观察（Observation）
Signal可以被观察通过observe函数，需要一个Observer作为参数，任何事件流都会发送给它。
signal.observe(Signal.Observer { event in
  switch event {
    case let .Next(next):
      print(&#34;Next: \(next)&#34;)
    case let .Failed(error):
      print(&#34;Failed: \(error)&#34;)
    case .Completed:
      print(&#34;Completed&#34;)
    case .Interrupted:
      print(&#34;Interrupted&#34;)
  }
})
"><link rel=stylesheet href=/css/semantic.min.css><link rel=stylesheet href=/css/icomoon.css><link rel=stylesheet href=/css/OverlayScrollbars.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/site.css><style>a:not(.ui.button):hover{text-decoration:underline}a:not(.ui.button){color:#2e8b57!important}.inverted a:not(.ui.button),.inverted a:not(.ui.button):hover{color:#8fbc8f!important}body.default{background-color:#f7f7f7;background-image:url(/me/background.jpeg)}body.dark{background-color:#000}</style><link rel=stylesheet data-highlight href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/gruvbox-light.min.css><link rel=stylesheet href=/css/custom.css></head><body class=default><nav class="ui secondary menu dream-menu"><div class=item><i class="large link bullseye icon dream-flip-toggle" title=翻转！></i></div><div class=item><i class="large link home icon" title=首页 onclick="window.location.href='https://lixianwa.github.io/'"></i></div><div class=item><i class="large link icon theme-switch" onclick=themeSwitch()></i></div><div class=item><i class="large link search icon" onclick=toggleSearch()></i></div></nav><div class=flip-container><div class=flipper><section class=front><div class=dream-max-width><div class="ui relaxed grid dream-grid dream-grid-single"><aside class="sixteen wide mobile sixteen wide tablet four wide computer column dream-single-aside"><div class="ui segment toc"><nav id=TableOfContents><ul><li><ul><li><a href=#事件流副作用>事件流副作用</a></li><li><a href=#组合算子operator-composition>组合算子（Operator composition）</a></li><li><a href=#合并事件流combining-event-streams>合并事件流（Combining event streams）</a></li><li><a href=#压缩zipping>压缩（Zipping）</a></li></ul></li></ul></nav></div><div class="ui segment actions"><button class="ui circular icon button save-as-image" title=保存为图片 onclick=savePostAsImg()>
<i class="save icon"></i></button>
<a href="https://twitter.com/intent/tweet?text=ReactiveCocoa%e4%b8%ad%e7%9a%84%e5%9f%ba%e6%9c%ac%e7%ae%97%e5%ad%90&url=https%3a%2f%2flixianwa.github.io%2fposts%2fbasic-operators%2f" class="ui circular twitter icon button"><i class="twitter icon"></i></a><a href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flixianwa.github.io%2fposts%2fbasic-operators%2f" class="ui circular facebook icon button"><i class="facebook icon"></i></a></div></aside><div class="sixteen wide mobile sixteen wide tablet twelve wide computer column markdown-body dream-single" id=dream-save-post-as-img><section class="ui attached segment"><header><h1 class="ui large header">ReactiveCocoa中的基本算子<div class="sub header">@
归零
|
星期日，八月 14 日，2016 年
| 2 分钟阅读
| 更新于
星期日，八月 14 日，2016 年</div></h1></header><article class=main><p>原文链接: <a href=https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/BasicOperators.md>Basic Operators</a></p><p>这个文档解释ReactiveCocoa中最常用的Operator，以及一些用例。注意Operators，在这里指的是signal和signal producers之间的转换，不是Swift中的操作符，换句话说，这些是ReactiveCocoa提供处理事件流的组合原语。该文档使用术语“事件流”来描述Signal和SignalProducer的概念。</p><h3 id=事件流副作用>事件流副作用</h3><h4 id=观察observation>观察（Observation）</h4><p>Signal可以被观察通过observe函数，需要一个Observer作为参数，任何事件流都会发送给它。</p><pre><code>signal.observe(Signal.Observer { event in
  switch event {
    case let .Next(next):
      print(&quot;Next: \(next)&quot;)
    case let .Failed(error):
      print(&quot;Failed: \(error)&quot;)
    case .Completed:
      print(&quot;Completed&quot;)
    case .Interrupted:
      print(&quot;Interrupted&quot;)
  }
})
</code></pre><p>或者可以用Next, Failed, Completed 和Interrupted事件的回调函数，当相应的事件发生时它（回调函数）会被调用。</p><pre><code>signal.observeNext { next in
  print(&quot;Next: \(next)&quot;)
}
signal.observeFailed { error in
  print(&quot;Failed: \(error)&quot;)
}
signal.observeCompleted {
  print(&quot;Completed&quot;)
}
signal.observeInterrupted {
  print(&quot;Interrupted&quot;)
}
</code></pre><p>注意可以不用观察所有四种类型的事件，因为参数是可选类型, 你只需要给你关心的事件提供回调函数。</p><h4 id=injecting-effects>Injecting effects</h4><p>SignalProducer会引入副作用，当使用on操作符但没有实际订阅它。</p><pre><code>let producer = signalProducer
  .on(started: {
    print(&quot;Started&quot;)
  }, event: { event in
    print(&quot;Event: \(event)&quot;)
  }, failed: { error in
    print(&quot;Failed: \(error)&quot;)
  }, completed: {
    print(&quot;completed&quot;)
  }, interrupted: {
    print(&quot;interrupted&quot;)
  }, terminated: {
    print(&quot;Terminated&quot;)
  }, disposed: {
    print(&quot;Disposed&quot;)
  }, next: { value in
    print(&quot;Next: \(value)&quot;)
  })
</code></pre><p>与observe类似，你只需要给你关心的事件提供回调函数。
注意不会有任何打印直到producer调用started（也许再其他任何地方调用started）。</p><h3 id=组合算子operator-composition>组合算子（Operator composition）</h3><h4 id=lifting>Lifting</h4><p>转换事件流
以下操作符可以将一个事件流转换成一个新的事件流。</p><h4 id=mapping>Mapping</h4><p>map用于事件流中所有的值，然后将结果创建成一个新的流。</p><pre><code>let (signal, observer) = Signal&lt;String, NoError&gt;.pipe()

signal
  .map{ string in string.uppercaseString }
  .observeNext { next in print(next) }

  observer.sendNext(&quot;a&quot;) //Prints A
  observer.sendNext(&quot;c&quot;) //Prints B
  observer.sendNext(&quot;c&quot;) //Prints C
</code></pre><h4 id=filtering>Filtering</h4><p><strong>filter</strong> 用于包含满足一定条件的事件流的值。</p><pre><code>let (signal, observer) = Signal&lt;Int, NoError&gt;.pipe()

signal
  .filter { number in number % 2 == 0 }
  .observeNext { next in print(next) }

observer.sendNext(1)   //Not printed
observer.sendNext(2)   //Prints 2
observer.sendNext(3)   //Not printed
observer.sendNext(4)   //Print 4
</code></pre><h5 id=聚集aggregating>聚集(Aggregating)</h5><p><strong>reduce</strong> 用于将一个事件流中的所有值聚集成一个单一的合并后得值，注意只有当输入的流完成时才会得到最后的结果。</p><pre><code>let (signal, observer) = Signal&lt;Int, NoError&gt;.pipe()
signal
  .reduce{ $0 * $1 }
  .observeNext{ next in print(next) }

observer.sendNext(1) //Not printed
observer.sendNext(2) //Not printed
observer.sendNext(3) //Not printed
observer.sendNext(4) //Not printed
observer.sendCompleted() //print 10
</code></pre><p><strong>collect</strong> 将一个事件流的所有值聚合到一个数组中，注意只有当输入的流完成时才会得到最后的结果。</p><pre><code>let (signal, observer) = Signal&lt;Int, NoError&gt;.pipe()

signal
    .collect()
    .observeNext { next in print(next) }

observer.sendNext(1)     // nothing printed
observer.sendNext(2)     // nothing printed
observer.sendNext(3)     // nothing printed
observer.sendCompleted()   // prints [1, 2, 3]
</code></pre><h3 id=合并事件流combining-event-streams>合并事件流（Combining event streams）</h3><p>这些操作会合并多个事件流中的值成一个新的、统一的流。</p><h4 id=合并最新的值combining-latest-values>合并最新的值（Combining latest values）</h4><p><strong>combineLatest</strong> 方法合并两个事件流最后的值。
产生的流将会发送它的第一个值当每一个输入流至少有一个值发送之后，之后，每一个输入流的新值产生一个新值输出。</p><pre><code>let (numbersSignal, numbersObserver) = Signal&lt;Int, NoError&gt;.pipe()
let (lettersSignal, lettersObserver) = Signal&lt;Int, NoError&gt;.pipe()

let signal = combineLatest(numbersSignal, lettersSignal)
signal.observeNext { next in print(next) }
signal.observeCompleted { print(&quot;Completed&quot;) }

numbersObserver.sendNext(0)      // nothing printed
numbersObserver.sendNext(1)      // nothing printed
lettersObserver.sendNext(&quot;A&quot;)    // prints (1, A)
numbersObserver.sendNext(2)      // prints (2, A)
numbersObserver.sendCompleted()  // nothing printed
lettersObserver.sendNext(&quot;B&quot;)    // prints (2, B)
lettersObserver.sendNext(&quot;C&quot;)    // prints (2, C)
lettersObserver.sendCompleted()  // prints &quot;Completed&quot;
combineLatestWith算子功能相同，不同的是它是一个算子。
</code></pre><h3 id=压缩zipping>压缩（Zipping）</h3><p><strong>zip</strong>函数结合两个事件流成一对。任何第N个元组的元素相当于第N个输入流的元素。
意思是说输出流的第N个值只有当每个输入流发送了至少N个值之后才会发送。</p><pre><code>let (numbersSignal, numbersObserver) = Signal&lt;Int, NoError&gt;.pipe()
let (lettersSignal, lettersObserver) = Signal&lt;String, NoError&gt;.pipe()

let signal = zip(numbersSignal, lettersSignal)
signal.observeNext { next in print(&quot;Next: \(next)&quot;) }
signal.observeCompleted { print(&quot;Completed&quot;) }

numbersObserver.sendNext(0)      // nothing printed
numbersObserver.sendNext(1)      // nothing printed
lettersObserver.sendNext(&quot;A&quot;)    // prints (0, A)
numbersObserver.sendNext(2)      // nothing printed
numbersObserver.sendCompleted()  // nothing printed
lettersObserver.sendNext(&quot;B&quot;)    // prints (1, B)
lettersObserver.sendNext(&quot;C&quot;)    // prints (2, C) &amp; &quot;Completed&quot;
</code></pre><p><strong>zipWith</strong>算子功能相同，不同之处是它是一个算子。</p></article></section><article class="ui segment utterances-comments" data-html2canvas-ignore><script src=https://utteranc.es/client.js repo=lixianwa/comments-for-myblog issue-term=og:title theme=github-light crossorigin=anonymous async></script></article></div></div><footer class="ui basic center aligned segment" style=background-color:initial><p>© 2014 - 2022 Lionel's Blog</p><p>Powered by <a href=https://gohugo.io/ target=_blank>Hugo</a> with theme <a href=https://github.com/g1eny0ung/hugo-theme-dream target=_blank>Dream</a>.</p></footer></div></section><section class=back><div class=dream-max-width><header class="ui basic very padded segment dream-header"><div class="ui small circular image"><img src=/me/avatar.jpeg alt=avatar></div><div class=content><h1 class="ui medium header">归零的小窝<div class="sub header">收集、总结、分享</div></h1><article class="ui horizontal list"><a class=item href=/posts><i class="archive icon" title=归档></i></a><a class=item href=/categories><i class="th list icon" title=所有分类></i></a><a class=item href=/tags><i class="tags icon" title=所有标签></i></a></article><article class=dream-tags><a class="ui label" href=/tags/archlinux/ title=archlinux>archlinux</a>
<a class="ui label" href=/tags/arthas/ title=arthas>arthas</a>
<a class="ui label" href=/tags/bug/ title=bug>bug</a>
<a class="ui label" href=/tags/c%E8%AF%AD%E8%A8%80/ title=c语言>c语言</a>
<a class="ui label" href=/tags/dapr/ title=Dapr>Dapr</a>
<a class="ui label" href=/tags/debug/ title=debug>debug</a>
<a class="ui label" href=/tags/dlv/ title=dlv>dlv</a>
<a class="ui label" href=/tags/go/ title=Go>Go</a>
<a class="ui label" href=/tags/grpc/ title=gRPC>gRPC</a>
<a class="ui label" href=/tags/headless-service/ title="Headless service">Headless service</a>
<a class="ui label" href=/tags/hexo/ title=Hexo>Hexo</a>
<a class="ui label" href=/tags/ios/ title=iOS>iOS</a>
<a class="ui label" href=/tags/java/ title=java>java</a>
<a class="ui label" href=/tags/jekyll/ title=jekyll>jekyll</a>
<a class="ui label" href=/tags/jupyter-notebook/ title="Jupyter notebook">Jupyter notebook</a>
<a class="ui label" href=/tags/kubernetes/ title=Kubernetes>Kubernetes</a>
<a class="ui label" href=/tags/markdown/ title=markdown>markdown</a>
<a class="ui label" href=/tags/mongodb/ title=mongodb>mongodb</a>
<a class="ui label" href=/tags/nginx/ title=nginx>nginx</a>
<a class="ui label" href=/tags/pandas/ title=Pandas>Pandas</a>
<a class="ui label" href=/tags/reactivecocoa/ title=ReactiveCocoa>ReactiveCocoa</a>
<a class="ui label" href=/tags/redis/ title=redis>redis</a>
<a class="ui label" href=/tags/restful-api/ title="RESTFul API">RESTFul API</a>
<a class="ui label" href=/tags/solid/ title=SOLID>SOLID</a>
<a class="ui label" href=/tags/swift/ title=Swift>Swift</a>
<a class="ui label" href=/tags/v2ray/ title=v2ray>v2ray</a>
<a class="ui label" href=/tags/xcode/ title=Xcode>Xcode</a>
<a class="ui label" href=/tags/%E5%86%85%E5%AD%98/ title=内存>内存</a>
<a class="ui label" href=/tags/%E5%8D%9A%E5%AE%A2/ title=博客>博客</a>
<a class="ui label" href=/tags/%E5%B7%A5%E5%85%B7/ title=工具>工具</a>
<a class="ui label" href=/tags/%E5%BC%80%E6%BA%90/ title=开源>开源</a>
<a class="ui label" href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/ title=微服务>微服务</a>
<a class="ui label" href=/tags/%E6%8F%90%E9%97%AE/ title=提问>提问</a>
<a class="ui label" href=/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ title=数据分析>数据分析</a>
<a class="ui label" href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/ title=数据库>数据库</a>
<a class="ui label" href=/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/ title=最佳实践>最佳实践</a>
<a class="ui label" href=/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ title=“机器学习”>“机器学习”</a>
<a class="ui label" href=/tags/%E6%AD%BB%E6%9C%BA/ title=死机>死机</a>
<a class="ui label" href=/tags/%E6%B3%9B%E5%9E%8B/ title=泛型>泛型</a>
<a class="ui label" href=/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/ title=“深度学习”>“深度学习”</a>
<a class="ui label" href=/tags/%E6%B8%B8%E8%AE%B0/ title=游记>游记</a>
<a class="ui label" href=/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/ title=科学上网>科学上网</a>
<a class="ui label" href=/tags/%E7%AE%97%E5%AD%90/ title=算子>算子</a>
<a class="ui label" href=/tags/%E7%BF%BB%E8%AF%91/ title=翻译>翻译</a>
<a class="ui label" href=/tags/%E8%87%AA%E8%A1%8C%E8%BD%A6/ title=自行车>自行车</a>
<a class="ui label" href=/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ title=读书笔记>读书笔记</a></article></div></header><div class="ui relaxed grid dream-grid dream-back"><div class="sixteen wide mobile eight wide tablet four wide computer column dream-column"><article class="ui segment markdown-body"><div class="ui medium header">关于</div><p>要么忙着生活，要么赶着去死!</p></article></div><div class="sixteen wide mobile eight wide tablet four wide computer column dream-column"><article class="ui segment"><div class="ui medium header">社交链接</div><nav class="ui secondary menu dream-menu dream-socials"><div class=item><a href=/index.xml><i class="large rss square icon" title=RSS></i></a></div><div class=item><a href=mailto:lixianwa@gmail.com><i class="large mail icon" title=Email></i></a></div></nav></article></div><div class="sixteen wide mobile eight wide tablet four wide computer column dream-column"><article class="ui segment"><a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/><img alt=知识共享许可协议 style=border-width:0 src=https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png></a><br>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</article></div></div></div></section></div></div><script>window.defaultDark=null,window.backgroundDark="black",window.backgroundImageDark=null,window.darkNav=null,window.hasTwitterEmbed=null,window.hasTwitterEmbed&&(window.twttr=function(c,d,e){var b,f=c.getElementsByTagName(d)[0],a=window.twttr||{};return c.getElementById(e)?a:(b=c.createElement(d),b.id=e,b.src='https://platform.twitter.com/widgets.js',f.parentNode.insertBefore(b,f),a._e=[],a.ready=function(b){a._e.push(b)},a)}(document,'script','twitter-wjs'))</script><script src=/js/jquery.min.js></script><script src=/js/semantic.min.js></script><script src=/js/jquery.overlayScrollbars.min.js></script><script src=/js/header.js></script><script src=/js/main.js></script><script src=/js/theme.js></script><script src=/js/html2canvas.min.js></script><script src=/js/post.js></script><script src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js></script><script src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/ocaml.min.js></script><script>hljs.initHighlightingOnLoad(),setHighlightTheme();function setHighlightTheme(){var a=localStore.getItem('hugo-theme-dream-is-dark'),b,c,d;a=a?a:window.defaultDark?'y':a,b="gruvbox-light",c="gruvbox-dark",d=a==='y'?c:b,$('link[data-highlight]').attr('href','https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/'+d+'.min.css'),$('pre').css('background',a==='y'?'#333':'')}</script><div class="ui inverted segment" id=dream-search><div class="ui search"><div class="ui transparent input"><input class=prompt type=text placeholder=搜索></div><div class=results></div></div></div><script>$(document).ready(function(){$.getJSON('https://lixianwa.github.io//index.json',function(a){$('.ui.search').search({source:a,searchFields:['title'],showNoResults:!0})})})</script><script src=/js/search.js></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','172168556','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>