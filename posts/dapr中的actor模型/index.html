<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><title>Dapr中的Actor模型 | Lionel's Blog</title><link href=/favicon.ico rel="shortcut icon" type=image/x-icon><meta name=author content="归零"><meta name=description content="原文链接：https://docs.dapr.io/developing-applications/building-blocks/actors/actors-overview/
介紹 Actor模型将Actor描述为最低层次的 &amp;ldquo;计算单元&amp;rdquo;。换句话说，你把代码写在一个独立的单元（称为Actor）中，这个单元每次接收消息并处理它们，没有任何并发或线程。
当你的代码处理一条消息时，它可以发送一条或多条消息给其他Actor，或者创建新的Actor。底层运行时管理每个Actor的运行方式、时间和地点，并在角色之间路由消息。
大量的actor可以同时执行，而且actor之间可以独立执行。
Dapr包括一个专门实现虚拟Actor模式的运行时。通过Dapr的实现，你可以根据Actor模式编写Dapr的actors，Dapr利用底层平台提供可扩展性和可靠性保证。
"><meta name=generator content="Hugo 0.81.0"><link rel=canonical href=https://lixianwa.github.io/posts/dapr%E4%B8%AD%E7%9A%84actor%E6%A8%A1%E5%9E%8B/><meta property="og:title" content="Dapr中的Actor模型"><meta property="og:description" content="原文链接：https://docs.dapr.io/developing-applications/building-blocks/actors/actors-overview/
介紹
Actor模型将Actor描述为最低层次的 &ldquo;计算单元&rdquo;。换句话说，你把代码写在一个独立的单元（称为Actor）中，这个单元每次接收消息并处理它们，没有任何并发或线程。
当你的代码处理一条消息时，它可以发送一条或多条消息给其他Actor，或者创建新的Actor。底层运行时管理每个Actor的运行方式、时间和地点，并在角色之间路由消息。
大量的actor可以同时执行，而且actor之间可以独立执行。
Dapr包括一个专门实现虚拟Actor模式的运行时。通过Dapr的实现，你可以根据Actor模式编写Dapr的actors，Dapr利用底层平台提供可扩展性和可靠性保证。"><meta property="og:type" content="article"><meta property="og:url" content="https://lixianwa.github.io/posts/dapr%E4%B8%AD%E7%9A%84actor%E6%A8%A1%E5%9E%8B/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-22T21:12:55+08:00"><meta property="article:modified_time" content="2021-04-22T21:12:55+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Dapr中的Actor模型"><meta name=twitter:description content="原文链接：https://docs.dapr.io/developing-applications/building-blocks/actors/actors-overview/
介紹
Actor模型将Actor描述为最低层次的 &ldquo;计算单元&rdquo;。换句话说，你把代码写在一个独立的单元（称为Actor）中，这个单元每次接收消息并处理它们，没有任何并发或线程。
当你的代码处理一条消息时，它可以发送一条或多条消息给其他Actor，或者创建新的Actor。底层运行时管理每个Actor的运行方式、时间和地点，并在角色之间路由消息。
大量的actor可以同时执行，而且actor之间可以独立执行。
Dapr包括一个专门实现虚拟Actor模式的运行时。通过Dapr的实现，你可以根据Actor模式编写Dapr的actors，Dapr利用底层平台提供可扩展性和可靠性保证。"><link rel=stylesheet href=/css/semantic.min.css><link rel=stylesheet href=/css/icomoon.css><link rel=stylesheet href=/css/OverlayScrollbars.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/site.css><style>a:not(.ui.button):hover{text-decoration:underline}a:not(.ui.button){color:#2e8b57!important}.inverted a:not(.ui.button),.inverted a:not(.ui.button):hover{color:#8fbc8f!important}body.default{background-color:#f7f7f7;background-image:url(/me/background.jpeg)}body.dark{background-color:#000}</style><link rel=stylesheet data-highlight href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/gruvbox-light.min.css><link rel=stylesheet href=/css/custom.css></head><body class=default><nav class="ui secondary menu dream-menu"><div class=item><i class="large link bullseye icon dream-flip-toggle" title=翻转！></i></div><div class=item><i class="large link home icon" title=首页 onclick="window.location.href='https://lixianwa.github.io/'"></i></div><div class=item><i class="large link icon theme-switch" onclick=themeSwitch()></i></div><div class=item><i class="large link search icon" onclick=toggleSearch()></i></div></nav><div class=flip-container><div class=flipper><section class=front><div class=dream-max-width><div class="ui relaxed grid dream-grid dream-grid-single"><aside class="sixteen wide mobile sixteen wide tablet four wide computer column dream-single-aside"><div class="ui segment toc"><nav id=TableOfContents><ul><li><a href=#介紹>介紹</a></li><li><a href=#何时使用actors>何时使用Actors</a></li><li><a href=#dapr中的actor>Dapr中的Actor</a></li><li><a href=#actor的生命周期>Actor的生命周期</a></li><li><a href=#分发和故障转移>分发和故障转移</a></li><li><a href=#-actor-placement-服务>### Actor placement 服务</a></li><li><a href=#actor通信>Actor通信</a></li><li><a href=#并发性>并发性</a><ul><li><a href=#turn-based-访问>Turn-based 访问</a></li></ul></li></ul></nav></div><div class="ui segment actions"><button class="ui circular icon button save-as-image" title=保存为图片 onclick=savePostAsImg()>
<i class="save icon"></i></button>
<a href="https://twitter.com/intent/tweet?text=Dapr%e4%b8%ad%e7%9a%84Actor%e6%a8%a1%e5%9e%8b&url=https%3a%2f%2flixianwa.github.io%2fposts%2fdapr%25E4%25B8%25AD%25E7%259A%2584actor%25E6%25A8%25A1%25E5%259E%258B%2f" class="ui circular twitter icon button"><i class="twitter icon"></i></a><a href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flixianwa.github.io%2fposts%2fdapr%25E4%25B8%25AD%25E7%259A%2584actor%25E6%25A8%25A1%25E5%259E%258B%2f" class="ui circular facebook icon button"><i class="facebook icon"></i></a></div></aside><div class="sixteen wide mobile sixteen wide tablet twelve wide computer column markdown-body dream-single" id=dream-save-post-as-img><section class="ui attached segment"><header><h1 class="ui large header">Dapr中的Actor模型<div class="sub header">@
归零
|
星期四，四月 22 日，2021 年
| 1 分钟阅读
| 更新于
星期四，四月 22 日，2021 年</div></h1></header><article class=main><p>原文链接：https://docs.dapr.io/developing-applications/building-blocks/actors/actors-overview/</p><h2 id=介紹>介紹</h2><p>Actor模型将Actor描述为最低层次的 &ldquo;计算单元&rdquo;。换句话说，你把代码写在一个独立的单元（称为Actor）中，这个单元每次接收消息并处理它们，没有任何并发或线程。</p><p>当你的代码处理一条消息时，它可以发送一条或多条消息给其他Actor，或者创建新的Actor。底层运行时管理每个Actor的运行方式、时间和地点，并在角色之间路由消息。</p><p>大量的actor可以同时执行，而且actor之间可以独立执行。</p><p>Dapr包括一个专门实现虚拟Actor模式的运行时。通过Dapr的实现，你可以根据Actor模式编写Dapr的actors，Dapr利用底层平台提供可扩展性和可靠性保证。</p><h2 id=何时使用actors>何时使用Actors</h2><p>与其他任何技术决策一样，你应该根据你要解决的问题来决定是否使用actor。</p><p>actor设计模式可以很好地适应一些分布式系统问题和场景，但你首先应该考虑的是模式的约束条件。一般来说，在以下情况下，可以考虑用actor模式来模拟你的问题或场景。</p><ul><li>你的问题空间涉及大量（数千或更多）小的，独立的，隔离的状态和逻辑单元。</li><li>你想使用单线程对象，这些对象不需要从外部组件中进行大量的交互，包括在一组actors中查询状态。</li><li>你的actor实例不会因为发出I/O操作而以不可预知的延迟来阻塞调用者。</li></ul><h2 id=dapr中的actor>Dapr中的Actor</h2><p>每一个actor都被定义为一个actor类型的实例，就像一个对象是一个类的实例一样。例如，可能有一个actor类型实现了计算器的功能，并且可能有许多该类型的actor分布在集群的不同节点上。每个这样的actor都由actor ID唯一标识。</p><p>![image](/images/actor_background_game_example.png | width=100)</p><h2 id=actor的生命周期>Actor的生命周期</h2><p>Dapr的Actor是虚拟的，这意味着它们的生命周期与它们在内存中的表现无关。因此，它们不需要被显式创建或销毁。Dapr Actors 运行时在第一次收到对该actor ID的请求时，会自动激活一个actor。如果一个actor在一段时间内没有被使用，Dapr Actors运行时就会对内存中的对象进行垃圾回收。如果以后需要重新激活它，它也会保持该actor存在的知识。</p><p>对actor方法的调用和提醒会重置idle time，例如，触发提醒会使actor保持活跃。无论actor是活跃还是不活跃，actor提醒都会被触发，如果触发不活跃的actor，它将首先激活actor。actor定时器不重置idle time，所以触发定时器不会使actor保持活跃状态。定时器只有在actor处于活动状态时才会触发。</p><p>Dapr运行时用来查看actor是否可以被垃圾回收的空闲时间和扫描间隔是可以配置的。当Dapr运行时调用actor服务以获取支持的actor类型时，可以传递这些信息。</p><p>由于虚拟actor模型的存在，这种虚拟actor生命周期抽象带有一些警告，事实上Dapr Actors的实现有时会偏离该模型。</p><p>在第一次向actor ID发送消息时该actor就会自动激活（导致一个actor对象被构造）。经过一段时间后，该actor对象会被垃圾回收。在未来，再次使用actor ID，会导致一个新的actor对象被构造。一个actor的状态会超过对象的生命周期，因为状态被存储在Dapr运行时配置的状态提供者中。</p><h2 id=分发和故障转移>分发和故障转移</h2><p>为了提供可扩展性和可靠性，actors实例分布在整个集群中，Dapr会根据需要自动将它们从故障节点迁移到健康节点。</p><p>actor分布在actor服务的实例中，这些实例分布在集群中的节点上。每个服务实例都包含一组给定类型的actor。</p><h2 id=-actor-placement-服务>### Actor placement 服务</h2><p>Dapr actor运行时为你管理分配方案和密钥范围设置。这是由actor Placement服务完成的。当创建一个新的服务实例时，相应的Dapr运行时会注册它可以创建的actor类型，并且Placement服务会计算给定类型的所有实例的分区。这些分区信息表会在运行环境中的每个Dapr实例中更新和存储，并且可以随着新的actor服务实例的创建和销毁而动态变化。如下图所示。
<img src=/images/actors_background_placement_service_registration.png alt=image></p><p>当client调用具有特定 id 的 actor（例如，actor id 123）时，client的 Dapr 实例会对 actor 类型和 id 进行哈希，并使用该信息调用到可以为该特定 actor id 的请求提供服务的相应 Dapr 实例。因此，对于任何给定的actor id，总是调用同一个分区（或服务实例）。如下图所示。</p><p><img src=/images/actors_background_id_hashing_calling.png alt=image></p><p>这简化了一些选择，但同时也要考虑一些问题。</p><ul><li><p>默认情况下，Actors被随机放置到pods中，已实现均匀分布。</p></li><li><p>因为actor是随机放置的，所以应该期望actor操作总是需要网络通信，包括方法调用的数据序列化和反序列化，会产生延迟和开销。</p></li></ul><blockquote><p>注意：Dapr actor Placement 服务仅用于演员放置，因此，如果您的服务没有使用 Dapr 演员，则不需要该服务。Placement服务可以在所有托管环境中运行，包括自托管和Kubernetes。</p></blockquote><h2 id=actor通信>Actor通信</h2><p>你可以通过HTTP/gRPC，与Dapr交互调用actor方法。</p><pre><code>POST/GET/PUT/DELETE http://localhost:3500/v1.0/actors/&lt;actorType&gt;/&lt;actorId&gt;/&lt;method/state/timers/reminders&gt;
</code></pre><p>你可以在request body中为actor方法提供任何数据，而请求的响应将在响应体中，即actor调用的数据。</p><p>更多细节请参考<a href=https://docs.dapr.io/developing-applications/building-blocks/actors/actors-overview/>Dapr Actor特性</a>。</p><h2 id=并发性>并发性</h2><p>Dapr Actors运行时提供了一个简单的基于回合的访问模型，用于访问actor方法。这意味着在任何时候，一个actor对象的代码中最多只能有一个线程处于活动状态。基于轮流访问大大简化了并发系统，因为不需要数据访问的同步机制。这也意味着在设计系统时，必须考虑到每个Actor实例的单线程访问特性。</p><p>单个actor实例一次不能处理一个以上的请求。如果期望一个actor实例处理并发的请求，它可能会造成吞吐量瓶颈。</p><p>如果两个actor之间存在循环请求，同时向其中一个actor发出外部请求，那么actor可能会相互死锁。Dapr actor运行时会自动超时处理actor调用，并向调用者抛出异常，以中断可能的死锁情况。</p><p><img src=/images/actors_background_communication.png alt=image></p><h3 id=turn-based-访问>Turn-based 访问</h3><p>A turn包括完整执行一个actor方法，以响应其他actor或客户端的请求，或者完整执行一个计时器/提醒回调。尽管这些方法和回调是异步的，但Dapr Actors运行时不会将它们交错在一起。在允许新的回合之前，一个回合必须完全完成。换句话说，在允许对方法或回调的新调用之前，当前正在执行的actor方法或计时器/提醒回调必须完全完成。如果方法或回调已从该方法或回调返回执行并且该方法或回调返回的任务已完成，则该方法或回调被视为已完成。值得强调的是，即使在不同的方法，计时器和回调中，也要尊重基于回合的并发。</p><p>Dapr actors运行时通过在开始时获取每个actor锁，并在结束时释放锁来强制执行Turn-based并发。因此，Turn-based 并发性是在每个Actor的基础上执行的，而不是跨Actor。Actor方法和定时器/提醒器回调可以代表不同的Actor同时执行。</p><p>下面的例子说明了上述概念。考虑一个实现了两个异步方法（比如Method1和Method2）、一个定时器和一个提醒器的actor类型。下图显示了代表属于该actor类型的两个actor（ActorId1和ActorId2）执行这些方法和回调的时间线的例子。</p><p><img src=/images/actors_background_concurrency.png alt=image></p></article></section><article class="ui segment utterances-comments" data-html2canvas-ignore><script src=https://utteranc.es/client.js repo=lixianwa/comments-for-myblog issue-term=og:title theme=github-light crossorigin=anonymous async></script></article></div></div><footer class="ui basic center aligned segment" style=background-color:initial><p>© 2014 - 2022 Lionel's Blog</p><p>Powered by <a href=https://gohugo.io/ target=_blank>Hugo</a> with theme <a href=https://github.com/g1eny0ung/hugo-theme-dream target=_blank>Dream</a>.</p></footer></div></section><section class=back><div class=dream-max-width><header class="ui basic very padded segment dream-header"><div class="ui small circular image"><img src=/me/avatar.jpeg alt=avatar></div><div class=content><h1 class="ui medium header">归零的小窝<div class="sub header">收集、总结、分享</div></h1><article class="ui horizontal list"><a class=item href=/posts><i class="archive icon" title=归档></i></a><a class=item href=/categories><i class="th list icon" title=所有分类></i></a><a class=item href=/tags><i class="tags icon" title=所有标签></i></a></article><article class=dream-tags><a class="ui label" href=/tags/archlinux/ title=archlinux>archlinux</a>
<a class="ui label" href=/tags/arthas/ title=arthas>arthas</a>
<a class="ui label" href=/tags/bug/ title=bug>bug</a>
<a class="ui label" href=/tags/c%E8%AF%AD%E8%A8%80/ title=c语言>c语言</a>
<a class="ui label" href=/tags/dapr/ title=Dapr>Dapr</a>
<a class="ui label" href=/tags/debug/ title=debug>debug</a>
<a class="ui label" href=/tags/dlv/ title=dlv>dlv</a>
<a class="ui label" href=/tags/go/ title=Go>Go</a>
<a class="ui label" href=/tags/grpc/ title=gRPC>gRPC</a>
<a class="ui label" href=/tags/headless-service/ title="Headless service">Headless service</a>
<a class="ui label" href=/tags/hexo/ title=Hexo>Hexo</a>
<a class="ui label" href=/tags/ios/ title=iOS>iOS</a>
<a class="ui label" href=/tags/java/ title=java>java</a>
<a class="ui label" href=/tags/jekyll/ title=jekyll>jekyll</a>
<a class="ui label" href=/tags/jupyter-notebook/ title="Jupyter notebook">Jupyter notebook</a>
<a class="ui label" href=/tags/kubernetes/ title=Kubernetes>Kubernetes</a>
<a class="ui label" href=/tags/markdown/ title=markdown>markdown</a>
<a class="ui label" href=/tags/mongodb/ title=mongodb>mongodb</a>
<a class="ui label" href=/tags/nginx/ title=nginx>nginx</a>
<a class="ui label" href=/tags/pandas/ title=Pandas>Pandas</a>
<a class="ui label" href=/tags/reactivecocoa/ title=ReactiveCocoa>ReactiveCocoa</a>
<a class="ui label" href=/tags/redis/ title=redis>redis</a>
<a class="ui label" href=/tags/restful-api/ title="RESTFul API">RESTFul API</a>
<a class="ui label" href=/tags/solid/ title=SOLID>SOLID</a>
<a class="ui label" href=/tags/swift/ title=Swift>Swift</a>
<a class="ui label" href=/tags/v2ray/ title=v2ray>v2ray</a>
<a class="ui label" href=/tags/xcode/ title=Xcode>Xcode</a>
<a class="ui label" href=/tags/%E5%86%85%E5%AD%98/ title=内存>内存</a>
<a class="ui label" href=/tags/%E5%8D%9A%E5%AE%A2/ title=博客>博客</a>
<a class="ui label" href=/tags/%E5%B7%A5%E5%85%B7/ title=工具>工具</a>
<a class="ui label" href=/tags/%E5%BC%80%E6%BA%90/ title=开源>开源</a>
<a class="ui label" href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/ title=微服务>微服务</a>
<a class="ui label" href=/tags/%E6%8F%90%E9%97%AE/ title=提问>提问</a>
<a class="ui label" href=/tags/%E6%95%99%E7%A8%8B/ title=教程>教程</a>
<a class="ui label" href=/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ title=数据分析>数据分析</a>
<a class="ui label" href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/ title=数据库>数据库</a>
<a class="ui label" href=/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/ title=最佳实践>最佳实践</a>
<a class="ui label" href=/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ title=“机器学习”>“机器学习”</a>
<a class="ui label" href=/tags/%E6%AD%BB%E6%9C%BA/ title=死机>死机</a>
<a class="ui label" href=/tags/%E6%B3%9B%E5%9E%8B/ title=泛型>泛型</a>
<a class="ui label" href=/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/ title=“深度学习”>“深度学习”</a>
<a class="ui label" href=/tags/%E6%B8%B8%E8%AE%B0/ title=游记>游记</a>
<a class="ui label" href=/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/ title=科学上网>科学上网</a>
<a class="ui label" href=/tags/%E7%AE%97%E5%AD%90/ title=算子>算子</a>
<a class="ui label" href=/tags/%E7%BF%BB%E8%AF%91/ title=翻译>翻译</a>
<a class="ui label" href=/tags/%E8%87%AA%E8%A1%8C%E8%BD%A6/ title=自行车>自行车</a>
<a class="ui label" href=/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ title=读书笔记>读书笔记</a></article></div></header><div class="ui relaxed grid dream-grid dream-back"><div class="sixteen wide mobile eight wide tablet four wide computer column dream-column"><article class="ui segment markdown-body"><div class="ui medium header">关于</div><p>要么忙着生活，要么赶着去死!</p></article></div><div class="sixteen wide mobile eight wide tablet four wide computer column dream-column"><article class="ui segment"><div class="ui medium header">社交链接</div><nav class="ui secondary menu dream-menu dream-socials"><div class=item><a href=/index.xml><i class="large rss square icon" title=RSS></i></a></div><div class=item><a href=mailto:lixianwa@gmail.com><i class="large mail icon" title=Email></i></a></div></nav></article></div><div class="sixteen wide mobile eight wide tablet four wide computer column dream-column"><article class="ui segment"><a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/><img alt=知识共享许可协议 style=border-width:0 src=https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png></a><br>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</article></div></div></div></section></div></div><script>window.defaultDark=null,window.backgroundDark="black",window.backgroundImageDark=null,window.darkNav=null,window.hasTwitterEmbed=null,window.hasTwitterEmbed&&(window.twttr=function(c,d,e){var b,f=c.getElementsByTagName(d)[0],a=window.twttr||{};return c.getElementById(e)?a:(b=c.createElement(d),b.id=e,b.src='https://platform.twitter.com/widgets.js',f.parentNode.insertBefore(b,f),a._e=[],a.ready=function(b){a._e.push(b)},a)}(document,'script','twitter-wjs'))</script><script src=/js/jquery.min.js></script><script src=/js/semantic.min.js></script><script src=/js/jquery.overlayScrollbars.min.js></script><script src=/js/header.js></script><script src=/js/main.js></script><script src=/js/theme.js></script><script src=/js/html2canvas.min.js></script><script src=/js/post.js></script><script src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js></script><script src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/ocaml.min.js></script><script>hljs.initHighlightingOnLoad(),setHighlightTheme();function setHighlightTheme(){var a=localStore.getItem('hugo-theme-dream-is-dark'),b,c,d;a=a?a:window.defaultDark?'y':a,b="gruvbox-light",c="gruvbox-dark",d=a==='y'?c:b,$('link[data-highlight]').attr('href','https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/'+d+'.min.css'),$('pre').css('background',a==='y'?'#333':'')}</script><div class="ui inverted segment" id=dream-search><div class="ui search"><div class="ui transparent input"><input class=prompt type=text placeholder=搜索></div><div class=results></div></div></div><script>$(document).ready(function(){$.getJSON('https://lixianwa.github.io//index.json',function(a){$('.ui.search').search({source:a,searchFields:['title'],showNoResults:!0})})})</script><script src=/js/search.js></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','172168556','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>